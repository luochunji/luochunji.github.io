<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[几种序列化工具的横向比较]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%87%A0%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7%E7%9A%84%E6%A8%AA%E5%90%91%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式-定义规范和流程的模板模式]]></title>
    <url>%2F2019%2F01%2F09%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%AE%9A%E4%B9%89%E8%A7%84%E8%8C%83%E5%92%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板（Template）模式，经常用来作为一个业务逻辑的骨架，在父类定义执行流程，具体到每个方法，将实现细节延申到之类中。模板模式不允许子类改变执行流程（step1、step2、step3由父类定义），流程中的每一步骤可以由子类重写。 类图以演示的烹饪类及其子类为例 实例模板模式涉及到两个角色： 抽象模板：定义一个或多个抽象操作以及由这些操作组合而成的流程方法； 具体模板：继承抽象模板并实现它定义的抽象方法，抽象模板可以有多个具体模板，每个具体模板对抽象方法有不同的实现。 以烹饪为例，抽象模板定义烹饪的流程 1234567891011121314151617181920212223//烹饪抽象类public abstract class Cook &#123; //声明为final，烹饪的流程不允许子类重写 public final void cook()&#123; //1、放油 putOil(); //2、放食物 putFood(); //3、放调味料 putSeason(); //4、烹饪 cooking(); //5、起锅（通用的方法，由父类实现） finish(); &#125; abstract void putOil(); abstract void putFood(); abstract void putSeason(); abstract void cooking(); final void finish()&#123; System.out.println("起锅"); &#125;&#125; 12345678910111213141516171819202122//红烧肉public class CookPork extends Cook &#123; @Override void putOil() &#123; System.out.println("放入猪油"); &#125; @Override void putFood() &#123; System.out.println("放入五花肉"); &#125; @Override void putSeason() &#123; System.out.println("撒盐、三勺醋、十三香"); &#125; @Override void cooking() &#123; System.out.println("红烧"); &#125;&#125; 1234567891011121314151617181920212223//爆炒青菜public class CookVegetable extends Cook &#123; @Override void putOil() &#123; System.out.println("放入花生油"); &#125; @Override void putFood() &#123; System.out.println("放入青菜"); &#125; @Override void putSeason() &#123; System.out.println("撒盐"); &#125; @Override void cooking() &#123; System.out.println("爆炒"); &#125;&#125; 测试类 12345678910public class TemplateTest &#123; public static void main(String[] args) &#123; Cook cookPork = new CookPork(); cookPork.cook(); System.out.println("-------------------"); Cook cookVegetable = new CookVegetable(); cookVegetable.cook(); &#125;&#125; 输出结果 1234567891011放入猪油放入五花肉撒盐、三勺醋、十三香红烧起锅-------------------放入花生油放入青菜撒盐爆炒起锅 使用场景父类定义规范和流程，子类实现每个步骤的具体流程，如JDBC的规范：开启事务、获取Session、提交事务、关闭Session，回滚等，这些步骤由不同ORM框架厂商实现并遵守，如Hibernate、Mybatis，开发人员不需要重复写这些代码，只要关注具体的CURD操作。再比如J2EE的servlet规范，定义了一套init/doGet/doPost/service……方法，这些方法不是抽象的，在servlet有默认的实现，但是它允许开发者重写这些方法，整体的调用流程还是由servlet控制，大大提高可扩展性，SpringMVC就是基于servlet的模板方法扩展； 总结模板模式的优点： 封装性好，在父类定义规范和不可变的流程，子类实现细节； 扩展性好，由子类实现方法扩展和修改，符合开闭原则； 提高代码复用； 缺点： 通过继承方式，导致每个不同的逻辑都必须要一个子类来实现，假如只有step3不同，其他步骤完全一致，也要两个类来分别实现，随着实现逻辑的增多，类会越来越庞大； 子类的逻辑会影响流程的执行结果，在代码阅读上增加了难度；]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式-过程不同结果相似的策略模式]]></title>
    <url>%2F2019%2F01%2F07%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%87%E7%A8%8B%E4%B8%8D%E5%90%8C%E7%BB%93%E6%9E%9C%E7%9B%B8%E4%BC%BC%E7%9A%84%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[从一个地点去另一个地点，你可以选择步行、出租车、公交车等各种交通工具，最终目的是到达目的地。每一种交通工具，还可以选择多种路线方案，避开拥堵、走捷径等等，每一种方案都是一种策略，这就是策略模式。 定义 简单来说，策略模式（Strategy）是一种过程不同、结果相同或者相似的设计模式。在程序设计中，为某个行为（例如查找、排序）定义一系列的算法并封装起来提供给调用者，最终由调用者决定使用哪一种，这里每一个算法都是一种策略，为了保证策略的一致性，通常会用一个抽象的策略类来定义算法，具体的细节由每一个策略类实现。 实例策略模式由三个角色组成 上下文 策略抽象 策略实现 以排序为例，传入一个未排序数字数组，最终返回有序数组，先定义策略抽象 1234public interface SortStrategy &#123; Integer[] sort(Integer[] unSortArray);&#125; 写三个排序算法：冒泡法、选择法、插入法 1234567891011121314151617181920212223//冒泡排序public class BubbleSort implements SortStrategy &#123; @Override public Integer[] sort(Integer[] arr) &#123; int i, temp, len = arr.length; boolean changed; do &#123; changed = false; len -= 1; for (i = 0; i &lt; len; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; changed = true; &#125; &#125; &#125; while (changed); System.out.println("冒泡排序结果:"+ Arrays.toString(arr)); return arr; &#125;&#125; 123456789101112131415161718192021//选择排序public class SelectionSort implements SortStrategy &#123; @Override public Integer[] sort(Integer[] arr) &#123; int min, temp; for (int i = 0; i &lt; arr.length; i++) &#123; min = i; for (int j = i+1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; temp = arr[min]; arr[min] = arr[i]; arr[i] = temp; &#125; System.out.println("选择排序结果:"+ Arrays.toString(arr)); return arr; &#125;&#125; 1234567891011121314151617//插入排序public class InsertionSort implements SortStrategy &#123; @Override public Integer[] sort(Integer[] arr) &#123; for (int i = 1; i &lt; arr.length; i++ ) &#123; int temp = arr[i]; int j = i - 1; for (; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j-- ) &#123; arr[j + 1] = arr[j]; &#125; arr[j + 1] = temp; &#125; System.out.println("插入排序结果:"+ Arrays.toString(arr)); return arr; &#125;&#125; 定义上下文 123456789101112public class Context &#123; private SortStrategy strategy; //必须调用者指定策略 public Context(SortStrategy strategy) &#123; this.strategy = strategy; &#125; public Integer[] doSort(Integer[] array)&#123; return strategy.sort(array); &#125;&#125; 测试类 1234567891011121314151617public class StrategyTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;8,7,4,9,5,3,1,2,6&#125;; Context context; //策略：冒泡排序 context = new Context(new BubbleSort()); context.doSort(array); //策略：插入排序 context = new Context(new InsertionSort()); context.doSort(array); //策略：选择排序 context = new Context(new SelectionSort()); context.doSort(array); &#125;&#125; 输出结果： 123冒泡排序结果:[1, 2, 3, 4, 5, 6, 7, 8, 9]插入排序结果:[1, 2, 3, 4, 5, 6, 7, 8, 9]选择排序结果:[1, 2, 3, 4, 5, 6, 7, 8, 9] 适用场景策略模式是对算法的封装，它把算法和结果分开，调用者需要知道都有哪些策略，而不必关心具体的实现细节，从而达到调用不同策略产生不同行为的结果。策略模式把选择权交给调用者，并且允许调用者自由替换，大大提高了灵活性，策略模式通常应用在以下场景： Java的比较器Comparator； 各种排序、查找、加密算法的封装； 调用者只关心结果，不关心过程； 存在大量if…else判断的复杂逻辑场景 总结策略模式的优点： 算法封装，完全符合“开闭原则”，不修改代码的基础上也可以更换实现策略，非常灵活； 避免过多的if…else造成可读性差的烂代码 缺点： 调用者必须知道所有的策略且策略要明确告知调用者运行结果； 一定程度上增加了类的数量；]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式-委派模式]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[委派（Delegate）模式，有两个类参与处理同一个请求，接受请求的类将请求委托给另一个类（被委派对象）来处理，具有保护被委派对象，隐藏实现细节的功能。委派模式至少必须两个类参与，以聚合取代继承。 实例项目外包：A公司从甲方承接了一个工程项目，然后外包给B公司，三个角色： 甲方（调用者） A公司（委派对象） B公司（被委派对象） 123456public class CompanyB &#123; public void doSomething()&#123; System.out.println("CompanyB doSomething"); &#125;&#125; 12345678public class CompanyA &#123; //实例化CompanyB private CompanyB delegate = new CompanyB(); //真正实施这个工程的是B公司 public void doSomething()&#123; delegate.doSomething(); &#125;&#125; 测试类 1234public static void main(String[] args) &#123; CompanyA companyA = new CompanyA(); companyA.doSomething();&#125; 结果 1CompanyB doSomething 特点 A类（委派类）和B类（被委派类）之间没有继承关系，A类中有一个属性为类B； A类B类有相同的方法和属性 与代理模式的区别代理模式满足两个角色：代理对象和被代理对象，与委派模式很像，但他们区别在于： 代理模式的代理类和被代理类可能有继承关系（cglib代理），委派模式类与类之间不需要继承； 代理类在调用代理类前/后做前置/后置处理，委派模式只是做单纯的调用； 委派模式可以层层委派，比如上例中B公司可以把工程再外包给C公司、C公司再外包给D公司……]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>委派模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式-原型模式]]></title>
    <url>%2F2019%2F01%2F04%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式（Prototype）是用于拷贝一个已经存在的实例，返回新的实例，被复制的实例就是所谓的“原型”，尤其是拷贝复杂对象，创建新的实例非常耗时，原型模式就可以解决性能的问题。 克隆何为克隆？就是复制一个一模一样的实例，Java中是通过clone方法来实现，以西游记中真假美猴王为例，假猴王有着和真猴王一模一样的长相、武器装备甚至各种能力，但是他们是两个不同的实例，可以说，假猴王是真猴王克隆的，Java中，可被克隆的对象一定要实现Cloneable接口，并且一定要覆盖父类的clone方法。 美猴王： 12345678910111213141516//真猴王，实现了Cloneable接口并覆盖父类clone方法public class MonkeyKing implements Cloneable &#123; //身高 private int height; //金箍棒 private GoldenStick goldenStick = new GoldenStick(); @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; //。。。省略set/get方法&#125; 金箍棒： 123456public class GoldenStick &#123; //金箍棒长度 private int length = 2; //。。。省略set/get方法&#125; 克隆一个假猴王（真猴王悟空，假猴王六耳猕猴） 1234567891011121314151617public class CloneTest &#123; public static void main(String[] args) &#123; try &#123; MonkeyKing wukong = new MonkeyKing(); wukong.setHeight(150); MonkeyKing mihou = (MonkeyKing) wukong.clone(); System.out.println("悟空 == 六耳猕猴: " + (wukong == mihou)); System.out.println("悟空王身高：" + wukong.getHeight()); System.out.println("六耳猕猴身高：" + mihou.getHeight()); System.out.println("悟空的金箍棒 == 六耳猕猴的金箍棒：" + (wukong.getGoldenStick() == mihou.getGoldenStick())); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 1234悟空 == 六耳猕猴： false悟空身高：150六耳猕猴身高：150悟空的金箍棒 == 六耳猕猴的金箍棒：true 真猴王的金箍棒 == 假猴王的金箍棒？显然是不对的，在这个例子中，假猴王的金箍棒复制的是真猴王金箍棒的引用，实际上他们仍然指向同一个金箍棒对象，这里引申出另一个概念：深拷贝和浅拷贝 浅拷贝Java中，除了基本数据类型和String以外，其他对象使用赋值操作，赋值的是该对象的引用，不是值。只是将引用传递过去，实际上还指向原来的对象，这就是浅拷贝。 深拷贝浅拷贝clone方法只能克隆当前基本数据类型成员变量的值，如果成员变量包含其他对象，那么必须在clone方法里逐一克隆成员变量。 GoldenStick实现Cloneable接口 1234567891011public class GoldenStick implements Cloneable&#123; private int length = 2; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; //。。。省略get/set方法&#125; 在MonkeyKing的clone方法中重写clone实现 123456789101112131415161718public class MonkeyKing implements Cloneable&#123; //身高 private int height; //金箍棒 private GoldenStick goldenStick = new GoldenStick(); @Override protected Object clone() throws CloneNotSupportedException &#123; MonkeyKing mihou = (MonkeyKing) super.clone(); //克隆金箍棒 mihou.goldenStick = (GoldenStick) goldenStick.clone(); return mihou; &#125; //。。。省略get/set方法&#125; 运行CloneTest 1234悟空 == 六耳猕猴： false悟空身高：150六耳猕猴身高：150悟空的金箍棒 == 六耳猕猴的金箍棒：false 结果可见，真假美猴王的金箍棒不再是同一个了。 但是，假如类有上百个成员变量，美猴王除了金箍棒还有紧箍咒、虎皮裙。。。按照这种方式是不是每个成员变量都要实现克隆接口，重写clone方法，然后在MonkeyKing中逐一克隆？显然这是一种效率低下且繁琐的做法，有什么办法能改进？没错，字节码拷贝！所有的类最终都是生成字节码，可以通过拷贝字节码来创建新的对象。 字节码拷贝字节码拷贝的前提条件是类必须是可序列化的，因此待拷贝的对象和其成员变量都要实现序列化接口 123public class MonkeyKing implements Serializable&#123; //省略&#125; 123public class GoldenStick implements Serializable&#123; //省略&#125; 拷贝方法和测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ClassDeepCopy &#123; //字节码深拷贝 public static MonkeyKing deepClone(MonkeyKing monkeyKing) &#123; ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try &#123; bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(monkeyKing); bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); return (MonkeyKing) ois.readObject(); &#125; catch (Throwable e) &#123; &#125; finally &#123; try &#123; bos.close(); oos.close(); bis.close(); ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; public static void main(String[] args) &#123; MonkeyKing wukong = new MonkeyKing(); wukong.setHeight(150); MonkeyKing mihou = ClassDeepCopy.deepClone(wukong); System.out.println("悟空 == 六耳猕猴： " + (wukong == mihou)); System.out.println("悟空身高：" + wukong.getHeight()); System.out.println("六耳猕猴身高：" + mihou.getHeight()); System.out.println("悟空的金箍棒 == 六耳猕猴的金箍棒：" + (wukong.getGoldenStick() == mihou.getGoldenStick())); &#125;&#125; 测试结果： 1234悟空 == 六耳猕猴： false悟空身高：150六耳猕猴身高：150悟空的金箍棒 == 六耳猕猴的金箍棒：false 使用场景 类的成员变量不多，又不想通过new方法来创建实例； 难以根据类生成实例； 类实例生成与框架解耦； 总结原型模式优点： 通过原型模式创建实例比new对象效率更高，对性能消耗明显或者对象复杂的类有显著作用； 对比New生成实例，不需要关心构造方法，简化创建实例； 缺点： 需要为每个非基本类型或String类型的成员变量重写clone方法，如果成员变量多，很繁琐； 如果修改已有的类的代码，违背了开闭原则；]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
        <tag>浅拷贝</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式-单例的几种写法]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[单例是Java中最简单也是最常用的设计模式之一，它属于创建型模式，在JVM的启动到停止期间，单例只允许类存在一个实例，这个类的实例是由类自己创建并提供给其他类访问，单例的三个特点： jvm中始终只有一个实例 由类自己创建 为其他类提供唯一实例 单例有多种写法，以下列举最常用的七种写法。 懒汉式懒汉式单例声明一个静态的instance = null的对象，因此类在初始化时，类并不会马上实例化，外部对象要调用该类的实例，只能通过getInstance方法，在第一次调用时进行实例化，起到延迟加载的作用。getInstance方法加了同步锁保证线程安全，但在并发时会造成性能瓶颈 12345678910111213141516171819202122public class LazySingleton &#123; /** * 类加载时并没有初始化（延迟加载） */ private static LazySingleton instance = null; private LazySingleton() &#123; //构造函数私有化 &#125; /** * 使用内置同步锁，线程安全，但在并发下会造成性能问题 * @return */ public static synchronized LazySingleton getInstance() &#123; if (null == instance) &#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; 饿汉式饿汉式单例与懒汉式的区别在于： 类初始化时就进行实例化； getInstance没有加锁; 没有延迟加载，也就意味着即使没有其他类调用，这个实例也一直存在，浪费内存资源，正因为初始化时就实例化，因此不存在线程安全问题，无需在getInstance上加同步锁； 1234567891011121314151617public class EagerSingleton &#123; /** * 类加载时已经初始化 */ private static EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; //私有化构造函数 &#125; /** * 直接返回已经类加载时已经实例化的对象，不存在线程安全问题 * @return */ public static EagerSingleton getInstance() &#123; return instance; &#125;&#125; 静态内部类式这种方式利用了 classloader 机制来保证初始化 instance 时只有一个线程，即使外部类被加载了，instance 还是未初始化，因为 SingletonHolder 类没有被显式调用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被显示调用从而被加载，那么这个时候用这种写法既可以实现延迟加载，又能保证线程安全性。 123456789101112131415161718192021public class InnerSingleton &#123; /** * 静态内部类在单例类初始化时不会初始化 */ private static class SingletonHolder &#123; private static InnerSingleton INSTANCE = new InnerSingleton(); &#125; private InnerSingleton() &#123; &#125; /** * 调用getInstance方法时，才去加载内部类，懒加载的同时也节约空间，同时也是线程安全的 * * @return */ public static InnerSingleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 双重校验式​双重校验在没有加volatile修饰符时是线程不安全的，多个线程之间彼此看到不到最新的变量值。volatile保证线程之间内存可见性。这种写法虽然用了同步锁，但只有第一次加载时会加锁，因此不存在性能问题。 1234567891011121314151617181920212223242526public class DoubleCheckSingleton &#123; /** * volatile修饰对象，保证线程间内存可见性的问题 */ private volatile static DoubleCheckSingleton instance; private DoubleCheckSingleton() &#123; &#125; public static DoubleCheckSingleton getInstance() &#123; //没有加volatile修饰符时，线程不安全，过程如下 //1、线程AB同时到达这里，此时instance == null if (instance == null) &#123; //2、只有一个线程能进入同步方法，假设A进入，线程B等待 synchronized (DoubleCheckSingleton.class) &#123; //3、线程A先进入，new对象后退出返回实例 //4、线程B后进入，因为线程A实例化后的类，对线程B不可见，此时instance == null，因 此线程B也进行new对象后返回实例 if (instance == null) &#123; instance = new DoubleCheckSingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 枚举式枚举式单例可以说是最简洁、最高效的单例模式，用最少的代码既保证实例唯一，又保证线程安全；缺点只有一个：它无法被继承。 1234567891011public enum EnumSingleton &#123; /** * 枚举变量 */ INSTANCE; public void method()&#123; &#125;&#125; ThreadLocal式很多时候，我们都在考虑线程间变量共享，而ThreadLocal刚好相反，它为每个线程提供一份独立的副本，隔离线程之间对同一变量访问的冲突，互不影响。 12345678910111213141516171819public class ThreadLocalSingleton &#123; /** * ThreadLocal为每个线程提供了副本，互不影响 */ private static final ThreadLocal&lt;ThreadLocalSingleton&gt; TL_SINGLETON = new ThreadLocal&lt;ThreadLocalSingleton&gt;() &#123; @Override protected ThreadLocalSingleton initialValue() &#123; return new ThreadLocalSingleton(); &#125; &#125;; private ThreadLocalSingleton() &#123; &#125; public static ThreadLocalSingleton getInstance() &#123; return TL_SINGLETON.get(); &#125;&#125; CAS式要获得唯一的实例，可以用利用AtomicReference的原子性，利用底层的CAS来实现 123456789101112131415161718192021222324public class CASSingleton &#123; private static AtomicReference&lt;CASSingleton&gt; instance = new AtomicReference&lt;&gt;(); private CASSingleton() &#123; &#125; public static CASSingleton getInstance() &#123; //自旋，直到唯一实例被创建 for (; ; ) &#123; CASSingleton singleton = instance.get(); if (null == singleton) &#123; singleton = new CASSingleton(); if (instance.compareAndSet(null, singleton)) &#123; return singleton; &#125; &#125; else &#123; return singleton; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写JDK动态代理]]></title>
    <url>%2F2018%2F12%2F31%2F%E6%89%8B%E5%86%99JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[JDK动态代理放寒假了，学生小明要回家，但是买不到火车票，只好找黄牛购票，用JDK的动态代理实现。 首先定义一个Student接口 123public interface Student &#123; void buy();&#125; 定义小明，实现Student接口 1234567public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println("我是小明，我要买票去上海的硬座"); &#125;&#125; 定义黄牛，实现InvocationHandler接口（JDK的动态代理一定要实现这个接口） 12345678910111213141516171819202122232425public class HuangNiu implements InvocationHandler &#123; private Student target; /** * 生成代理对象 * @param target * @return */ public Object getInstance(Student target) &#123; this.target = target; Class clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("我是黄牛，你要什么票?"); System.out.println("--------------"); method.invoke(target, args); System.out.println("--------------"); return null; &#125;&#125; 测试类： 1234567public class ProxyTest &#123; public static void main(String[] args) &#123; Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 输出结果： 1234我是黄牛，你要什么票?--------------------我是小明，我要买票去上海的硬座-------------------- 小明要购票，小明不需要自己去售票处，而是找了黄牛，让黄牛代劳，真正购票的人是黄牛 小明 ==&gt;被代理对象 黄牛 ==&gt;代理对象 这时候，运行的是黄牛这个代理类，试着将Proxy.newProxyInstance方法生成的代理类输出 1234567891011121314151617181920212223242526/** * 输出代理对象class * * @param proxy */ private void output(Object proxy) &#123; String className = proxy.getClass().getSimpleName(); String baseDir = getClass().getResource("").getPath(); byte[] data = ProxyGenerator.generateProxyClass(className, new Class[]&#123;Student.class&#125;); FileOutputStream os = null; try &#123; os = new FileOutputStream(baseDir + "/" + className + ".class"); os.write(data); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 得到$Proxy0.class文件（生成的代理类名都是以“$”为前缀，数字为后缀），反编译后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class $Proxy0 extends Proxy implements Student &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void buy() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m3 = Class.forName("com.cjluo.chapter1.proxy.jdk.Student").getMethod("buy"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 代理类对被代理对象的所有方法都做了代理，通过代理类的InvocationHandler.invoke调用，因此，自己实现动态代理的关键步骤就是： 生成动态代理类； 编译并代理类并加载代理类class文件； 返回代理类给调用者； 以上涉及的JDK动态代理相关类有 123InvocationHandlerProxyClassLoader 自己实现动态代理首先定义CustomerInvocationHandler接口 1234public interface CustomerInvocationHandler &#123; Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 理一下JDK动态代理的逻辑，方法的调用者调用的是小明的代理对象 ==&gt;黄牛，因此要定义CustomerProxy并在该类中生成黄牛这个代理类： 123456789101112131415161718192021222324252627282930313233public class CustomerProxy &#123; //硬编码代理对象名称 private static final String proxyClassName = "$Proxy0"; public static Object newProxyInstance(CustomerClassLoader loader, Class&lt;?&gt;[] interfaces, CustomerInvocationHandler h) &#123; try &#123; //1、生成代理类java文件 File f = generatorProxy(interfaces); //2、编译代理类java为class compilerJava(f); //3、自定义加载器加载class Class clazz = loader.findClass(proxyClassName); //4、生成代理对象并返回 Constructor c = clazz.getConstructor(CustomerInvocationHandler.class); return c.newInstance(h); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 生成代理类java文件代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 生成代理类java文件 * * @param interfaces * @return */private static File generatorProxy(Class&lt;?&gt;[] interfaces) &#123; //接口名 Class clazz = interfaces[0]; String interfaceName = clazz.getName(); //换行 String newLine = "\r\n"; StringBuffer sb = new StringBuffer(); sb.append("package " + clazz.getPackage().getName() + ";").append(newLine); sb.append("import java.lang.reflect.Method;").append(newLine); sb.append("public class " + proxyClassName + " implements " + interfaceName + "&#123;").append(newLine); sb.append("protected CustomerInvocationHandler h;").append(newLine); sb.append("public " + proxyClassName + "(CustomerInvocationHandler h)&#123;").append(newLine); sb.append(" this.h = h; ").append(newLine); sb.append("&#125;").append(newLine); for (Method m : clazz.getMethods()) &#123; sb.append("public " + m.getReturnType().getName() + " " + m.getName() + "()&#123;").append(newLine); sb.append("try&#123;").append(newLine); sb.append("Method m = " + interfaceName + ".class.getMethod(\"" + m.getName() + "\",new Class[]&#123;&#125;);").append(newLine); sb.append("this.h.invoke(this,m,null);").append(newLine); sb.append("&#125;catch(Throwable e)&#123;").append(newLine); sb.append("&#125;").append(newLine); sb.append("&#125;").append(newLine); &#125; sb.append("&#125;").append(newLine); String src = sb.toString(); File file = new File(CustomerProxy.class.getResource("").getPath() + "/" + proxyClassName + ".java"); try &#123; FileWriter fw = new FileWriter(file); fw.write(src); fw.flush(); fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return file;&#125; 编译代理类 123456789101112131415161718192021/** * 编译代理类 * * @param f */private static void compilerJava(File f) &#123; //java编译器 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager manager = compiler.getStandardFileManager(null, null, null); Iterable iterable = manager.getJavaFileObjects(f); JavaCompiler.CompilationTask task = compiler.getTask(null, manager, null, null, null, iterable); task.call(); try &#123; manager.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //删除Java文件 f.delete(); &#125;&#125; 自定义加载器加载class 123456789101112131415161718192021222324252627282930313233343536373839public class CustomerClassLoader extends ClassLoader &#123; private File baseDir; public CustomerClassLoader() &#123; String basePath = CustomerClassLoader.class.getResource("").getPath(); this.baseDir = new File(basePath); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String className = getClass().getPackage().getName() + "." + name; if (baseDir != null) &#123; File classFile = new File(baseDir, name.replaceAll("\\.", "/") + ".class"); if (classFile.exists()) &#123; FileInputStream in = null; ByteArrayOutputStream out = null; try &#123; in = new FileInputStream(classFile); out = new ByteArrayOutputStream(); byte[] buff = new byte[1024]; int len; while ((len = in.read(buff)) != -1) &#123; out.write(buff, 0, len); &#125; return defineClass(className, out.toByteArray(), 0, out.size()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //删除class文件 classFile.delete(); &#125; &#125; &#125; return null; &#125;&#125; 测试类： 1234567public class CustomerProxyTest &#123; public static void main(String[] args) &#123; Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 运行结果 1234我是黄牛，你要什么票?--------------------我是小明，我要买票去上海的硬座--------------------]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式 - 代理模式]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式是JAVA常用的设计模式之一，代理模式不直调用代理对象，而是通过对象的代理类来处理，好比是中介、黄牛、经纪人，代理模式又分为静态代理和动态代理。 代理对象：面向调用者，在调用者和被代理对象之间作为隔离层加以控制，可以增强被代理对象的方法。 被代理对象：真正的执行者，需要对代理对象暴露 静态代理何为静态？其实就是在编码阶段，写好代理类，然后编译运行，在程序运行前，代理类已经存在。 以学生小明找黄牛购票为例： 123public interface Student &#123; void buy();&#125; 小明： 123456public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println("我是学生小明，我要一张去上海的票"); &#125;&#125; 黄牛： 123456789101112131415161718public class HuangNiu implements Student &#123; private Student target; //代理类实例化时需要传入被代理类实例的引用 public HuangNiu(Student student) &#123; this.target = student; &#125; @Override public void buy() &#123; System.out.println("我是黄牛，你要什么票？"); System.out.println("------------"); //调用被代理类的方法 this.target.buy(); System.out.println("------------"); &#125;&#125; 测试类： 12345678public class StaticProxyTest &#123; public static void main(String[] args) &#123; Student xiaoMing = new XiaoMing(); HuangNiu huangNiu = new HuangNiu(xiaoMing); huangNiu.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票？------------我是学生小明，我要一张去上海的票------------ 动态代理相对于静态代理，动态代理的代理类是在运行时生成，动态代理在实现上又有两种，分别是jdk动态代理和cglib动态代理。 JDK动态代理JDK动态代理要求被代理对象必须实现接口，其原理是代理对象实现该接口的方法，同时调用被代理对象的方法。将生成后的代理对象，强制转换为接口被调用者调用。还是以小明和黄牛为例： 小明，实现学生接口的buy方法 1234567public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println("我是学生，我要买票去上海的硬座"); &#125;&#125; 黄牛，作为小明的代理实现InvocationHandler 12345678910111213141516171819202122232425public class HuangNiu implements InvocationHandler &#123; private Student target; /** * 生成代理对象 * * @param target * @return */ public Object getInstance(Student target) &#123; this.target = target; Class clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("我是黄牛，你要什么票?"); System.out.println("--------------"); //代理对象持有被代理对象实例的引用，通过反射调用目标方法 method.invoke(target, args); System.out.println("--------------"); return null; &#125; 测试类： 1234567891011public class ProxyTest &#123; public static void main(String[] args) &#123; /** * 实例化代理类时调用getInstance方法传入了小明的实例，生成代理类==&gt;黄牛，强制转换为Student * 接口，因此实际上是由黄牛去执行买票操作； */ Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票?--------------我是学生，我要买票去上海的硬座-------------- HuangNiu类没有直接实现Person接口，而是通过反射生成字节码文件的方式，动态生成真正的代理类。 Cglib动态代理与JDK动态代理不同的是，cglib代理不强制被代理类实现接口，它是通过生成代理类的子类，并重写代理类方法来实现的，所以代理类不能用final修饰，还是以小明和黄牛为例： 小明： 123456public class XiaoMing &#123; public void buy() &#123; System.out.println("我是学生，我要买票去上海的硬座"); &#125;&#125; 黄牛： 12345678910111213141516171819202122232425//MethodInterceptor是cglibpublic class HuangNiu implements MethodInterceptor &#123; public Object getInstance(Class clazz)&#123; //cglib封装的高性能的代码生成库 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(clazz); //回调当前实例 enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object target, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("我是黄牛，你要什么票?"); System.out.println("--------------"); //注意，这里如果用invoke会造成死循环，因为代理类是被代理类的子类，如果调用invokeSuper方法， //会调用父类的方法，而invoke会重复进入当前代理类的方法，造成死循环 methodProxy.invokeSuper(target,objects); System.out.println("--------------"); return null; &#125;&#125; cglib动态代理并没有像JDK动态代理那样，直接持有代理类实例的引用，那么intercept方法的第一个参数Object是怎么生成？根据类加载的顺序，实例化子类前，必先实例化其父类 实例化 ChildClass ==&gt; new FatherClass ==&gt; new ChildClass； 测试类： 1234567public class CglibProxyTest &#123; public static void main(String[] args) &#123; XiaoMing p = (XiaoMing) new HuangNiu().getInstance(XiaoMing.class); p.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票?--------------我是学生，我要买票去上海的硬座-------------- 应用场景代理模式随处可见，最常见的是spring的AOP，比如spring的事务代理，在对数据进行操作时会涉及事务开启、事务提交、事务回滚等操作，简化的数据操作模型如下图： 业务场景中存在大量的事务操作（红色），而这些往往不是开发者的关注点，开发者更注重于业务逻辑（蓝色）。因此代理模式可以增强业务逻辑代码，在事务执行前开启事务，在事务执行后进行回滚/提交/关闭。 总结 静态代理需要编写代理类，动态代理不需要； 静态代理在无需修改被代理类的前提下，对代理类进行增强和扩展，但是静态代理只能对一个被代理类服务，如果被代理类过多，就会产生相应数量的代理类实现与被代理类一致的接口，产生冗余，不易维护； JDK动态代理只要求代理类实现InvocationHandler接口，被代理类实现业务接口即可。 静态代理编译时生成的class的性能高于JDK动态代理通过反射生成class； cglib不要求被代理类实现接口，而是通过继承的方式实现，因此类和方法都不能用final修饰。cglib底层用高性能的字节码生成器，性能高于反射。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>静态代理</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式-隐藏细节的工厂模式]]></title>
    <url>%2F2018%2F12%2F28%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%9A%90%E8%97%8F%E7%BB%86%E8%8A%82%E7%9A%84%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[如果你要一台宝马，带上钱，去宝马4S店，就可以买到宝马； 如果你要一台奔驰，带上钱，去奔驰4S点，就可以买到奔驰； 如果你要一台奥迪…… 你需要什么，就给你什么，而不需要关心它的细节，这就是工厂模式，工厂模式负责生产调用者需要的“产品”（实例）。通常所说的工厂模式，有这三种： 简单工厂（simple factory） 工厂方法（factory method） 抽象工厂（abstract factory） 逐一分析，先定义Car接口 1234public interface Car &#123; String getName();&#125; 再分别定义宝马、奔驰、奥迪三个“产品” 1234567//宝马public class Bmw implements Car &#123; @Override public String getName() &#123; return "Bmw"; &#125;&#125; 1234567//奥迪public class Audi implements Car &#123; @Override public String getName() &#123; return "Audi"; &#125;&#125; 1234567//奔驰public class Benz implements Car &#123; @Override public String getName() &#123; return "Benz"; &#125;&#125; 简单工厂定义SimpleFactory： 123456789101112131415public class SimpleFactory &#123; public static Car getCar(String name) &#123; if ("bmw".equalsIgnoreCase(name)) &#123; return new Bmw(); &#125; else if ("benz".equalsIgnoreCase(name)) &#123; return new Benz(); &#125; else if ("audi".equalsIgnoreCase(name)) &#123; return new Audi(); &#125;else&#123; System.out.println("没有你要的车！"); return null; &#125; &#125;&#125; 测试类： 12345678910111213public class SimpleFactoryTest &#123; public static void main(String[] args) &#123; Car car = SimpleFactory.getCar("benz"); System.out.println(car.getName()); car = SimpleFactory.getCar("bmw"); System.out.println(car.getName()); car = SimpleFactory.getCar("audi"); System.out.println(car.getName()); &#125;&#125; 测试结果： 123BenzBmwAudi 简单工厂简单粗暴，就像一个强大的汽车制造商，生产BBA甚至更多品牌的汽车，客户想要什么车，工厂就生产什么车，如果生产不了，返回null。 我们思考一下，现实中有没有这种工厂，既可以生产奔驰，又可以生产宝马和奥迪？不存在的。一般是奥迪工厂生产奥迪、奔驰工厂生产奔驰，宝马工厂生产宝马。。。这时候就要对简单工厂进行改造，产生了工厂方法模式。 工厂方法首先要有一个汽车工厂接口，这个接口定义了一套汽车生产规范和流程，所有的汽车制造商都要按照这个规范和流程生产汽车。 1234//汽车工厂public interface CarFactory &#123; Car getCar();&#125; 然后各制造商按照这个规范生产汽车，具体怎么造，各厂商自己去实现细节。 宝马工厂 1234567//宝马工厂public class BmwFactory implements CarFactory &#123; @Override public Car getCar() &#123; return new Bmw(); &#125;&#125; 奥迪工厂 1234567//奥迪工厂public class AudiFactory implements CarFactory &#123; @Override public Car getCar() &#123; return new Audi(); &#125;&#125; 奔驰工厂 1234567//奔驰工厂public class BenzFactory implements CarFactory &#123; @Override public Car getCar() &#123; return new Benz(); &#125;&#125; 客户需要哪个品牌的汽车，就去找哪个工厂生产，测试类： 12345678910111213public class FunFactoryTest &#123; public static void main(String[] args) &#123; Car car = new BmwFactory().getCar(); System.out.println(car.getName()); car = new BenzFactory().getCar(); System.out.println(car.getName()); car = new AudiFactory().getCar(); System.out.println(car.getName()); &#125;&#125; （运行结果同简单工厂模式，就不列举了） 方法工厂不同于简单工厂之处在于，它做了细分，把大而全的工厂拆解成多个工厂生产不同的“产品”，职责清晰，目标明确，但是方法工厂缺点在于，客户要自己找到这个工厂才能得到想要的车，实际上这是不合理的，因此结合简单工厂和方法工厂，又衍生出了抽象工厂。 抽象工厂试想一下，客户要某个品牌的车，还得自己去找对应品牌的工厂，这种需要客户介入的行为是很不友好的，假如有一个经销商，它负责对客户收单，然后让对应的工厂去生产客户想要的车，这就完美解决了以上问题。 抽象工厂类： 1234567891011121314151617181920//结合了简单工厂和方法工厂的抽象工厂类public abstract class AbstractCarFactory &#123; //定制一个造车流程和规范，让各造车厂商去实现 protected abstract Car getCar(); //从客户获取订单，从对应的工厂获取客户想要的车 public Car getCar(String name) &#123; if ("bmw".equalsIgnoreCase(name)) &#123; return new BmwFactory().getCar(); &#125; else if ("benz".equalsIgnoreCase(name)) &#123; return new BenzFactory().getCar(); &#125; else if ("audi".equalsIgnoreCase(name)) &#123; return new AudiFactory().getCar(); &#125; else &#123; System.out.println("没有你要的车"); return null; &#125; &#125;&#125; 各造车工厂 1234567//奥迪工厂public class AudiFactory extends AbstractCarFactory &#123; @Override protected Car getCar() &#123; return new Audi(); &#125;&#125; 1234567//奔驰工厂public class BenzFactory extends AbstractCarFactory &#123; @Override protected Car getCar() &#123; return new Benz(); &#125;&#125; 1234567//宝马工厂public class BmwFactory extends AbstractCarFactory &#123; @Override protected Car getCar() &#123; return new Bmw(); &#125;&#125; 因为抽象类无法实例化，通常都有一个默认实现，定义一个默认的工厂 12345678910//默认工厂public class DefaultCarFactory extends AbstractCarFactory &#123; //指定默认的工厂为奥迪工厂 private AudiFactory factory = new AudiFactory(); @Override protected Car getCar() &#123; return factory.getCar(); &#125;&#125; 测试类： 12345678910public class AbstractCarFactoryTest &#123; public static void main(String[] args) &#123; AbstractCarFactory factory = new DefaultCarFactory(); Car car = factory.getCar("bmw"); if(null != car)&#123; System.out.println(car.getName()); &#125; &#125;&#125; 应用场景spring中bean的创建就使用了工厂模式，各种bean工厂都实现了BeanFactory接口，调用者只需要输入beanName或者id，工厂就可以生成所需要的Bean。 网络传输协议的选择，调用者只需要描述需要什么协议，比如HTTP/TCP/POP3，协议工厂便可以生产对应的实现。 总结 工厂模式将类的实例化过程完全隐藏，调用者只需要传入类名，就可以获得所需的实例，如果在代码中存在大量的new实例化对象，万一改了类的构造方法，对代码的破坏简直是灾难，必须将所有相关的代码一一修改，如果你用工厂模式，就可以避免这种事发生。 简单工厂对类实例化的简单封装，它的缺点是不利于拓展，工厂并非真的大而全，如果要增加一个工厂，哪怕只是简单的修改if/else代码块，也是违背面向对象设计的开闭原则; 工厂方法对简单工厂进行了抽象，每个产品都由单独的工厂来创建，要新增产品，只要新增这个产品的工厂，完全遵循对修改关闭，对扩展开放的原则；但是工厂方法需要调用者明确哪个工厂生产什么并且显式的调用，并没有完全解耦； 抽象工厂又是对工厂方法的进一步封装，同类产品由同一工厂生产，它的缺点是抽象工厂如果存在多个产品，子类必须实现所有的抽象方法，相当于开了整套的流水线。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis-数据类型]]></title>
    <url>%2F2018%2F08%2F06%2FRedis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[redis的数据类型有五种，分别是 字符串 散列（哈希） 列表 集合 有序集合 redis也是一种基于内存的数据库，五种数据类型的共同之处是数据都以Key-Value键值对保存，对于习惯了Java的程序员来说，Map的Key和Value可以自定义，value还可以嵌套Map/List/Set，比如Map&lt;String,Object&gt; m，Object可以是任意的数据类型，但是这种在redis中是不允许的，key只能是一个类型，例如字符串的Key如果存入的value为散列数据，那么redis会抛出一个错误 说明这个key已经存入了其他数据类型的value。接下来逐个介绍各种数据类型。 字符串字符串是reids最基本的数据类型，可以存储图片、字符、Json格式化的对象，一个字符串类型允许存储的大小最大512MB（已经很大了，内存可是很宝贵的！） 常用命令（斜体表示形式参数，[]表示可选参数） table th:nth-of-type(3) { width: 85px; # 可使用%比例 } table th:last-of-type { width: 45%; } 命令 功能 复杂度 可选参数 说明 set key value [p] 保存key-value O(1) ex second px millisecondnxxx 设置过期时间为秒设置过期时间为毫秒key不存在时，才执行setkey存在时，才执行set get key 读取key的value O(1) key不存在，返回(nil) incr key 整数递增 O(1) key不存在，创建，value先初始化为0，然后+1key不是数字，抛出异常key为数字，+1且返回递增后的值 incrby key increment 按 increment递增 O(1) 与incr相似increment&gt;0，增加数值increment&lt;0，减少数值返回值为计算后的结果 decr key 整数递减 O(1) key不存在，创建，value先初始化为0，然后-1key不是整数，抛出异常key为整数，-1且返回递减后的值 decrby key increment 按 increment递减 O(1) 与decrby相似increment&gt;0，减少数值increment&lt;0，增加数值返回值为计算后的结果 incrbyfloat key increment 增加指定浮点值 O(1) increment如果是整数，效果等同于incrby增量可以用科学计数法表示，如3e5,4e-2increment&gt;0，减少数值increment&lt;0，增加数值返回值为计算后的结果 append key value 尾部追加 O(1) 如果key不存在，等同于set key value，否则追加value，返回追加后的长度 strlen key 计算value字符串长度 O(1) 如果key不存在，返回0对于中文或其他字符，按照实际utf-8的编码长度返回，如“你好”，返回的长度是6 mset key… 批量设置key-value O(N) 操作多个key时，是一个原子操作如果成功，则所有key都同时设置 mget key… 批量获取key-value O(N) 如果给定的key不存在，返回nil setbit key offset value 设置偏移量上的bit O(1) value只能是0或1当key不存在时，自动生成一个新的字符串，扩容时，非填充的位置以0填充offser的值在[0,2^32)之间 getbit key offset 获取偏移量上的bit O(1) 如果offset大于字符串的长度，或者key不存在，返回0 bitcount key [start] [end] 统计bit被设置为1的数量 O(N) startend 起始位置结束位置 bitop [op] destkey key… 对key进行位操作结果保存到destkey上 O(N) andorxornot 逻辑且逻辑或逻辑异或逻辑非 bitpos key bit [start] [end] 返回第一个被设置为1或0的bit位 O(N) startend 起始位置结束位置 应用实例以上字符串命令在项目中会经常使用，关于bit的相关操作，很有必要掌握，确实解决了很多业务和性能问题。最常遇到的应该是统计用户活跃度问题，举个例子，产品要求统计上线以来，每个用户的活跃度曲线，我们要做的就是两件事， 统计每个用户的活跃天数，具体的访问日期 根据维度、粒度绘制曲线图 这种统计方式与关系型数据库相比，性能更高，也不用写复杂的SQL，取得数据后就是绘制曲线图，这不是本文的重点，就不详述了。如果有其他的统计需求，比如用户A第一次使用产品或某个日期区间内第一次使用产品的日期，可以使用bitpos命令， 散列（哈希）散列也是以kv结构存储，与Java的Map很像，但是它的value只能是字符串，也就是无法像Map那样可以嵌套。散列的存储结构可以简单的用下图表示 常用命令 命令 功能 复杂度 说明 hset key field value 设置key中的field值为value O(1) 如果field不存在且value设置成功，返回1如果field已存在，新值将覆盖旧值，返回0 hget key field 获取key中指定域的值 O(1) hmset key field value [field value…] 设置一个或多个field-value对 O(N) 如果filed已存在，将会覆盖 hmget key field… 获取key中一个或多个域的值 O(N) key不存在，返回nilfield不存在，返回nil hgetall key 获取key所有域和值 O(N) hexists key field 判断field是否存在 O(1) 如果field存在，返回1如果field不存在，或key不存在，返回0 hsetnx key field value 当且仅当field不存在时，赋值为value O(1) 如果field存在，不执行赋值操作如果key不存在，相当于创建key并赋值field hincrby key field increment 让key中的field按increment递增 O(1) field的value不是数字，报错increment&gt;0，增加数值increment&lt;0，减少数值以上返回值为计算后的结果 hincrbyfloat key field increment 让key中的field按increment浮点数递增 O(1) 同hincrby hdel key field… 删除key的一个或多个field O(N) 返回成功删除field的个数 hkeys key 只获取key的所有field O(N) 包含所有field的表当key不存在时，返回一个空表 hvals key 只获取key的所有field的值 O(N) 包含所有value的表当key不存在时，返回一个空表 hlen key 返回field的数量 O(1) key不存在时，返回0 应用实例有了散列数据类型，当作为数据库时，一个用户的属性包含id，姓名，性别，联系电话，在关系型数据库的表结构可以表示为 Id name gender mobile 1 张三 男 135xxxxxx 2 李四 男 135xxxxxx 用redis的散列可以表示为 假如要增加一个属性驾驶证号码，这个属性只针对id=1的数据有效，对于其他数据是冗余的，那么只能对表结构进行修改，增加一个字段 Id name gender mobile cardId 1 张三 男 135xxxxxx xxxxxx 2 李四 男 135xxxxxx null redis的散列结构不需要这么做，它的存储结构都是独立的，可以自由的增减field，不影响其他field 列表列表类型可以存储一个有序的字符串列表，支持双端操作，底层的实现是双向链表，所以两端添加元素时性能很高，越接近两端的元素越快，但是随机访问的性能就比较差，这跟Java的链表很相似。 常用命令 命令 功能 复杂度 说明 lpush key value… 将一个或多个value插入key列表的表头 O(1) 返回列表的长度 rpush key value… 将一个或多个value插入key列表的表尾 O(1) 返回列表的长度 lpop key 移除并返回key列表的头元素 O(1) 返回列表的头元素当key不存在时，返回nil rpop key 移除并返回key列表的尾元素 O(1) 返回列表的尾元素当key不存在时，返回nil llen key 返回列表的长度 O(1) 如果key不存在，返回0如果key不是列表类型，报错 lrange key start end 返回列表key中起始和结束区间内的元素 O(S+N) start end以0为底，可以&gt;0也可以&lt;0为0时表示最左边第一个元素1表示最左边第二个元素-1表示最右边第一个元素-2表示最右边第二个元素，依此类推start end的区间为闭区间，包含start和end下标的元素如果start&gt;列表最大下标，返回空列表如果end&gt;列表的最大下标，则返回到最右边的元素 lrem key count value 移除列表中与value相等的元素 O(N) count&gt;0，从表头开始向表尾遍历删除与value相等的元素，数量为countcount&lt;0，从表尾开始向表头遍历删除与value相等的元素，数量为count的绝对值count=0，删除所有表中与value相等的元素 lindex key index 返回列表中下标为index的元素 O(N) index&gt;0，列表从表头开始遍历第index个元素index&lt;0，列表从表尾开始遍历第index个元素 lset key index value 将下标为index的元素值设置为value O(N) index&gt;0，列表从表头开始遍历第index个元素 index&lt;0，列表从表尾开始遍历第index个元素 linsert key Before/After pivot value 将value插入列表中插入pivot之前或之后 O(N) 在列表中不存在pivot值时，不执行操作key不存在时，不执行操作 rpoplpush src dest 将列表src的表尾元素弹出插入列表dest的表头 O(1) 弹出的元素会作为返回值返回如果src不存在，返回nil，不执行其他操作如果dest不存在，创建dest列表如果src和dest相同，等同于将表尾元素移到表头 集合集合与列表有一些相似之处，也很容易区分，集合的元素是不可重复的，与Java的HashSet类似，也是无序的。 常用命令 命令 功能 复杂度 可选参数 说明 sadd key member… 将一个或多个member元素加入到集合key中 O(N) 如果key不存在，自动创建已存在与集合的member元素将被忽略成功则返回加入的元素数量（忽略的元素不计算在内） srem key member… 将一个或多个member元素删除 O(N) 返回成功移除的元素数量 smembers key 返回集合key中的所有元素 O(N) key不存在，返回空集合 sismember key member 判断元素member是否在集合key中 O(1) 如果member元素在集合key中，返回1如果key不存在或member元素不在集合key中，返回0 sdiff key… 差集运算 O(N) 当key不存在，视为空集合返回差集集合 sidffstore dest key… 差集运算，将结果保存到dest中 O(N) dest如果已存在，将其覆盖dest可以是key自身返回结果集中的元素数量 sinter key… 交集运算 O(N*M) 当key不存在，视为空集合返回交集集合 sinterstore dest key… 交集运算，将结果保存到dest中 O(N*M) dest如果已存在，将其覆盖dest可以是key自身返回结果集中的元素数量 sunion key… 并集运算 O(N) 当key不存在，视为空集合返回并集集合 sunionstore dest key… 并集运算，将结果保存到dest中 O(N) dest如果已存在，将其覆盖dest可以是key自身返回结果集中的元素数量 scard key 获取集合key的元素数量 O(1) 返回集合个数，当key不存在时，返回0 srandmember key 随机获取集合key中的一个或多个元素（取决于count的大小） O(1)O(N) count 当0&lt;count&lt;集合size，返回count个不重复的元素当count&gt;=集合size，返回整个集合当count&lt;0，返回count个可能重复的元素当key不存在，未提供count参数，返回nil当key不存在，提供count参数，返回空集合 spop key 删除并返回集合中的一个随机元素 O(1) 返回被移除的随机元素当key不存在或key是空集合，返回nil smove src dest member 将member元素从src集合移动到dest集合 O(1) 当src不存在或member元素不在src中，不执行任何操作，当dest中已包含member元素，该操作仅将src的member元素删除如果member元素在src中且被成功移除，返回1如果member元素不是src集合成员，并且没有对dest执行操作返回0 有序集合有序集合与集合的区别就在于它是有序的，在集合的基础上，有序集合中的元素多了一个score属性，使得有序集合可以基于score进行排序等与数值有关的操作，有序集合和列表也有些相似，以下是列表、集合、有序集合三者的比较 列表 集合 有序集合 是否有序 ✔ x ✔ 是否唯一 x ✔ ✔ 底层实现 链表 散列表 散列表和跳表 有序集合与列表的差异还在于： 列表访问两端的元素很快，元素越多，访问中间的元素越慢，有序集合基于散列表和跳表实现，读取中间部门的数据也很快 列表无法简单的调整元素的位置，有序集合可以 常用命令 命令 功能 复杂度 可选参数 说明 zadd key score member [score member …] 将一个或多个member元素及其score加入有序集合key中 O(M*log(N)) 当member元素已存在有序集合中将更新score值和元素的位置如果key不存在，创建一个有序集合并执行插入操作返回成功添加的元素数量（不包含已存在的元素） zscore key member 获得元素的score O(1) 如果key不存在或member元素不在有序集合key中，返回nil zrange key start stop [withscores] 获取有序集合key中，指定区间内的元素 O(log(N)+M) withscores 按照score从小到大的顺序返回索引从start到stop之间的所有元素如果start或stop大于0，表示从前向后查找如果start或stop小于0，表示从后向前查找-1表示最后一个与元素可选参数withscores表示一起返回元素和score值例如元素1，score1，元素2，score2… zrevrange key start stop [withscores] 获取有序集合key中，指定区间内的元素 O(log(N)+M) withscores 与zrange不同的是，zrevrange是按照从大到小的顺序来排列 zrangebyscore key min max [withscores] [limit offset count] 获取有序集合 key 中，所有 score 值介于 min 和max 之间(包括等于 min 或 max )的元素。 O(log(N)+M) withscoreslimit offset count 有序集合元素按 score 值递增(从小到大)次序排列withscores参数会将score一起返回，limit参数指定返回结果的数量和区间，类似sql的 select limit offset countmin，max在默认情况下的取值为闭区间也可以通过加(符号来使用开区间 zincrby key increment member 为一个元素的score值加上增量increment O(log(N)) 返回元素新的score值当key不存在，或member不在有序集合key中时，等同于zadd key score member当increment&gt;0，增加score当increment&lt;0，减少score zcard key 获取有序集合key中元素的数量 O(1) 返回有序集合元素个数当key不存在时，返回0 zcount key min max 获取有序集合key中，score值在min和max之间（包括等于min或max）的元素数量 O(log(N)+M) 返回score值在min和max之间的元素数量 zrem key member … 删除有序集合key中一个或多个member元素 O(M*log(N)) 如果member不存在，忽略否则返回成功删除的元素数量（不包含忽略的元素） zremrangebyrank key start stop 删除有序集合key中指定排名(rank)区间内(包含start和stop)的所有元素 O(log(N)+M) 有序集合按照score从小到大排序删除start和stop区间内（包含start和stop）的元素当start或stop&gt;0，表示从前向后查找当start或stop&lt;0，表示从后向前查找 zremrangebyscore key min max 删除有序集合key中，指定score区间内的所有元素 O(log(N)+M) 有序集合按照score从小到大排序，删除score区间在min和max之间的元素默认情况下，删除的元素包含等于min或max的元素，可以使用(符号表示开区间 zrank key member 获取member元素在有序集合key中从小到大排序后的索引 O(log(N)) score值最小的索引为0 zrevrank key member 获取member元素在有序集合key中从大到小排序后的索引 O(log(N)) score值最大的索引为0 zinterstore dest numkeys key …[weights weight…][aggregate sum/min/max] 计算给定的一个或多个有序集合的交集其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 dest O(NK)+O(Mlog(M)) weightsaggregate weights，设置每个集合的权重，参与计算时元素要乘上该集合的权重aggregate默认取值为sum，计算每个元素score的和设置为min时，计算每个元素的最小score值设置为max时，计算每个元素的最大score值 zunionstore dest numkeys key …[weights weight…][aggregate sum/min/max] 计算给定的一个或多个有序集合的并集其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 dest O(N)+O(Mlog(M)) weightsaggregate 同zinterstore命令]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redis数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis安装]]></title>
    <url>%2F2018%2F08%2F04%2FRedis%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在学习Redis之前，首先要安装redis的运行环境，了解它的基础命令和基本知识。 下载redis 进入redis官网的下载页面https://redis.io/download 从这个页面我们可以得到的一些基本信息是，redis分为稳定版和非稳定版，其中偶数版本号为稳定版，奇数版本号为非稳定版。截至目前（2018年8月）最新的稳定版为4.0.11，Beta版为5.0-rc4，如果要下载之前的版本，页面往下拉 有oldVersion可以选择，直接提供下载的是3.2.12版本，如果要找其他版本，你可以通过这个连接http://download.redis.io/releases/下载，我安装的是3.0版本（3.0应该是redis的一个里程碑，加入集群支持后，redis完成了分布式的实现，新的embedded string编码格式，LRU算法的优化和其他性能的提升，如果之前接触过Redis，这些功能应该让你感到兴奋，从此memcache有的功能，redis几乎都有了，技术选型中使用redis将是更好的选择） 安装redis在linux下安装 我是在centos6的虚拟机上安装，输入以下命令 1234wget http://download.redis.io/releases/redis-3.0.0.tar.gztar xzf redis-3.0.0.tar.gzcd redis-3.0.0make 逐行执行，成功后再执行 1make install 将启动命令等复制到bin目录中，方便以后敲命令，linux下安装编译比较简单，没有其他依赖。 在windows下安装redis官网上没有windows的安装包，微软发了个补丁让redis可以在windows下运行，但是考虑今后的生产环境应该都会使用linux，所以在windows下也建议以虚拟机或Cygwin的方式运行redis（Cygwin是一个类似虚拟机的linux模拟环境，它将linux下的软件重编译后在linux下运行，而且他的软件包还提供了上千个工具，windows下学习linux相关应用的神器！！！） 首先，在Cygwin官网上下载http://www.cygwin.com/setup-x86_64.exe，根据提示选择下载方式、安装路径、最后出现软件包安装界面 将gcc和make的组件勾选，我这里显示”keep”是因为已经安装过了，如果没安装过，显示的是版本号，Skip表示不安装。 然后下载redis的源码，命令与linux下安装时一样，但是要注意，在make之前还要修改src目录下的redis.h文件，在头部加入 12345#ifdef CYGWIN#ifndef SA ONSTACK#define SA ONSTACK 0x08000000#endif#endif cygwin的文件路径就是安装路径，例如D:\cygwin64\，修改文件可以直接找到目录下的文件，用文本编辑器打开修改，也可以在linux下用vim修改。 修改之后在redis根目录执行make，如果报错，请参考这篇文章《redis3.0.6安装（linux和windows）》 启停Redis 首先来了解几个文件，在执行make install之后，redis的几个常用可执行文件会复制到Cygwin的bin目录下，因此可以通过直接输入命令来运行，省去路径 文件/命令 说明 redis-server redis服务端启动 redis-cli redis客户端启动 redis-benchmark redis性能测试 redis-check-aof aof文件修复工具 redis-check-dump rdb文件检查工具 redis-sentinel sentinel服务 启动redis1$ redis-server 出现以上提示，表示启动成功 redis的默认端口为 6379，如果要修改端口，可以用以下参数启动（xxxx用实际端口号替换） 1$ redis-server --port xxxx 也可以通过 1$ redis-server -h 或 $ redis-server --help 查看其他启动参数，具体的启动参数如下 参数 说明 省略 按照默认配置启动 /etc/xxx.conf 按照指定的配置文件启动 -v 或 –version 查看redis版本号 -slaveof ip port 将当前服务器转为指定服务器的slave –loglevel xxx 配置日志级别，xxx有4个可选参数，分别是debug\verbose\notice\warning 停止Redisredis支持优雅停机，在客户端发送shutdown命令，会先断开客户端连接，然后根据配置执行持久化策略，完成后退出 1$ redis-cli shutdown redis可以处理系统的kill命令，效果与shutdown一样，但是kill -9 命令将直接终止redis进程，无法优雅停机 启动命令行客户端 1$ redis-cli 和启动服务端一样，启动客户端也可以使用启动参数 参数 说明 -h hostname，服务端的ip -p port，服务端的端口 -s socket 包含了hostname和port -a password 服务端密码 -r n，n表示重复执行的次数，如-r 100 -i 配合-r命令，命令执行的间隔时间 -n 选择数据库，默认是0 -x 从磁盘/缓冲区读取 -d 设置换行符，默认是”\n” -c 启用集群 –raw 返回格式化后的输出信息 –no-row 返回原始的输出信息 –csv 以csv格式输出 –stat 查看redis服务的实时状态，基本信息包含keys数量\memory大小\client数量\blocked统计请求数\连接数等 –latency 服务延迟持续采样，一般用于监视性能，输出平均延时时间 –latency-history 服务延迟持续采样，间隔时间输出，大概每15秒左右输出一组结果 –latency-dist 服务延迟采样，以带色块的频谱（这个翻译可能不太好）输出，默认每1秒输出一行，可以用-i参数修改 –lru-test 针对某个key，测试lru算法 –slave slave服务 –rdb 转储rdb到本地文件 –pipe 将redis协议格式的数据发送的服务端执行 –pipe-timeout 功能同上，带超时参数，默认30秒，如果服务端没有返回结果，自动终止 –bigkeys 查找占用内存较大的key，列出每种数据类型key的最大size和平均size –scan 扫描redis的key –pattern 以sacn的方式，扫描指定的pattern –intrinsic-latency 测试系统延迟，需在server上执行 –eval 执行lua脚本]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>Cygwin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务详解(一)]]></title>
    <url>%2F2018%2F05%2F31%2FSpring%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[什么是事务事务（Transaction）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。 事务的四大特性（ACID）： 原子性（Atomicity），每个事务都是一个不可分割的工作单元，事务的操作结果要么都执行成功，要么都执行失败。 一致性（Consistency），事务必须是使数据库从一个一致性状态到另一个一致性状态。 隔离性（Isolation），事务与事务之间的执行不能互相干扰，即一个事务内部的操作及使用的数据对并发的其他事务是不可见的。 持久性（Durability），又叫做永久性（Permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久的，后续的其他操作或异常都不应该对其有任何影响。 事务操作的基本流程 事务开启（begin） 事务执行（execute） 事务提交（自动提交AutoCommit / 手动提交CustomCommit）/事务回滚（rollback）（假如出现错误） 事务关闭（close） 事务的基本原理Spring事务是基于数据库对事务的支持，数据库不支持事务，Spring是无法提供事务功能，下表列出了对事务支持/不支持的主流数据库产品 数据库产品 事务支持 MySql（MyISAM） ❌ MySql（InnoDB） ✔ PostgreSql ✔ SQL Server ✔ Oracle ✔ Sybase ✔ MongoDb ❌ Spring封装了JDBC的数据库操作，可以按照以下步骤进行 获取连接Connection con = DriverManager.getConnection() 开启事务，设置自动提交属性con.setAutoCommit（true/false） 执行CRUD 提交事务/回滚事务con.commit()/con.rollback() 关闭连接 con.close() Spring事务传播性Spring事务的传播性，就是在多个事务同时存在时，Spring如何处理这些事务的行为，在 TransactionDefinition中定义了如下属性 事务类型 作用 PROPAGATION_REQUIRED Spring默认传播属性，如果当前没有事务，新建一个事务 PROPAGATION_REQUIRES_NEW 新起事务，如果当前存在事务，则挂起当前事务，新起的事务与被挂起的事务不存在关联关系，各自独立，外层事务失败回滚，不会回滚内层事务执行的结果，内层事务失败抛出异常，外层事务可以捕获，是否回滚由业务决定 PROPAGATION_SUPPORTS 如果当前没有事务，就以非事务的方式执行 PROPAGATION_MANDATOR 如果当前没有事务，抛出异常 PROPAGATION_NOT_SUPPORTED 以非事务的方式执行操作，如果当前已存在事务，则挂起当前事务 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常 PROPAGATION_NESTED 如果存在一个活动的事务，则运行在嵌套事务中，如果没有活动事务，则按照PROPAGATION_REQUIRED类型执行，内部事务的回滚不会对外部事务造成影响，只对DataSourceTransactionManager 事务管理器有效 数据库隔离级别很多数据库管理系统定义了不同的“事务隔离等级”来控制锁的程度。隔离级别越高，锁的开销越大，同时也会增加死锁发生的几率，需要根据实际业务场景详细分析，设置合理的隔离级别。下表列出了数据库的隔离级别 隔离级别 级别值 说明 Read-Uncommitted（读未提交） 0 可能导致脏读 Read-Committed（读已提交） 1 避免脏读，允许不可重复度和幻读 Repeatable-Reads（可重复读） 2 避免脏读，不可重复读，允许幻读 Serializable （可串行化） 3 串行化，事务一个一个执行，避免脏读、不可重复度、幻读。执行效率低，谨慎使用 脏读事务A对数据进行了增删改，但是未提交，事务B可以读取到事务A未提交的数据，如果事务A此时回滚了，那么事务B读取到的就是脏数据 不可重复读在事务A中，进行了两次读操作，第一次读和第二次读操作之间，另外一个事务B对数据行了修改，造成事务A两次读取的数据不一致。 幻读事务A使用Where条件对一些数据进行查询，此时事务B插入一条数据，这条数据刚好满足事务A的Where条件，导致事务A两次查询出的结果集不一致。 隔离级别越高，数据完整性和一致性就越能得到保证，但是对并发性能的影响也越大 大多数的数据库默认级别是Read-Commited，如SqlServer、Oracle 有一些数据库的默认级别是Repeatable Read，如Mysql（InnoDB） Spring中的隔离级别Spring的事务是基于数据库的，因此隔离级别和数据库差不多，只是多了个默认级别，如下： Spring隔离级别 解释 ISOLATION_DEFAULT PlatfromTransactionManager默认的隔离级别，与选用数据库的默认隔离级别相同 ISOLATION_READ_UNCOMMITTED 最低的隔离级别，同数据库的Read-Uncommitted ISOLATION_READ_COMMITTED 同数据库的Read-Committed ISOLATION_REPEATABLE_READ 同数据库的Repeatable-Reads ISOLATION_SERIALIZABLE 同数据库的Serializable Spring事务嵌套通过上面的数据库事务理论知识，大致了解数据库事务和Spring事务的一些属性和特点，接着分析一些嵌套事务的场景，了解Spring事务的传播机制。 PROPAGATION_REQUIRED（Spring默认）支持当前事务，如果当前没有事务，创建一个事务执行 以ServiceA的methodA()调用ServiceB的methodB()为例， 如果methodA()，methodB()的事务级别定义为PROPAGATION_REQUIRED，那么执行该方法的时候，已经有了事务，此时调用ServiceB.methodB()，发现已经运行在methodA()的事务内，就不再起新事务； 如果ServiceB.methodB()被调用时并没有在事务中，就会新建一个事务运行； 此时无论是methodA()异常还是methodB()异常，事务都会被回滚。 PROPAGATION_REQUIRES_NEW新建事务，如果当前已存在事务，则把当前事务挂起。 假设ServiceA.methodA()的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB()的事务级别为PROPAGATION_REQUIRES_NEW，当执行methodB()时，methodA()所在的事务就被挂起了，等methodB()的事务执行完，才能继续执行methodA()的事务。 这种情况下，内层事务（methodB()的事务）如果已提交，外层事务（methodA()的事务）异常不会导致内层事务回滚。反之内层事务抛出的异常，可以由外层事务捕获，至于外层事务要不要回滚，取决于对异常的处理。 PROPAGATION_SUPPORTS支持当前事务，如果当前没有事务，以非事务的方式执行。这个比较好理解，methodA()如果存在事务，methodB()就加入当前事务中，如果没有事务，则methodB()也不开启事务，内层事务完全依赖于外层事务。 PROPAGATION_MANDATORY支持当前事务，如果当前没有事务，抛出异常。也很好理解，方法必须运行在事务下，如果外层事务不存在，抛异常。 PROPAGATION_NOT_SUPPORTED以非事务方式执行，如果当前存在事务，则挂起当前事务。 PROPAGATION_NEVER与PROPAGATION_MANDATORY相反，PROPAGATION_NEVER完全以非事务方式执行，如果存在事务，抛异常。 PROPAGATION_NESTED这个传播属性就相对复杂了，如果methodB()声明为PROPAGATION_NESTED，在执行methodB()时如果回滚，内层事务将回到一个保存点（SavePoint），而外层事务methodA()该如何处理？可以有以下两个方式： 捕获异常，在catch块里增加业务处理； 回滚/提交]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring事务</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务</tag>
        <tag>事务隔离</tag>
        <tag>事务传播</tag>
      </tags>
  </entry>
</search>
