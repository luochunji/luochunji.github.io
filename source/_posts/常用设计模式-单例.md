---
title: 常用设计模式-单例的几种写法
date: 2019-01-03 20:12:18
tags:
- 设计模式
- 单例
categories: 
- 设计模式
---

单例是Java中最简单也是最常用的设计模式之一，它属于创建型模式，在JVM的启动到停止期间，单例只允许类存在一个实例，这个类的实例是由类自己创建并提供给其他类访问，单例的三个特点：

1. jvm中始终只有一个实例
2. 由类自己创建
3. 为其他类提供唯一实例

单例有多种写法，以下列举最常用的七种写法。

<!-- more -->

## 懒汉式

懒汉式单例声明一个静态的instance = null的对象，因此类在初始化时，类并不会马上实例化，外部对象要调用该类的实例，只能通过getInstance方法，在第一次调用时进行实例化，起到延迟加载的作用。getInstance方法加了同步锁保证线程安全，但在并发时会造成性能瓶颈

```java
public class LazySingleton {

    /**
     * 类加载时并没有初始化（延迟加载）
     */
    private static LazySingleton instance = null;

    private LazySingleton() {
        //构造函数私有化
    }

    /**
     * 使用内置同步锁，线程安全，但在并发下会造成性能问题
     * @return
     */
    public static synchronized LazySingleton getInstance() {
        if (null == instance) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

## 饿汉式

饿汉式单例与懒汉式的区别在于：

1. 类初始化时就进行实例化；

2. getInstance没有加锁;

   没有延迟加载，也就意味着即使没有其他类调用，这个实例也一直存在，浪费内存资源，正因为初始化时就实例化，因此不存在线程安全问题，无需在getInstance上加同步锁；

```java
public class EagerSingleton {
    /**
     * 类加载时已经初始化
     */
    private static EagerSingleton instance = new EagerSingleton();

    private EagerSingleton() {
        //私有化构造函数
    }
    /**
     * 直接返回已经类加载时已经实例化的对象，不存在线程安全问题
     * @return
     */
    public static EagerSingleton getInstance() {
        return instance;
    }
}
```

## 静态内部类式

这种方式利用了 classloader 机制来保证初始化 instance 时只有一个线程，即使外部类被加载了，instance 还是未初始化，因为 SingletonHolder 类没有被显式调用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被显示调用从而被加载，那么这个时候用这种写法既可以实现延迟加载，又能保证线程安全性。

```java
public class InnerSingleton {

    /**
     * 静态内部类在单例类初始化时不会初始化
     */
    private static class SingletonHolder {
        private static InnerSingleton INSTANCE = new InnerSingleton();
    }

    private InnerSingleton() {
    }

    /**
     * 调用getInstance方法时，才去加载内部类，懒加载的同时也节约空间，同时也是线程安全的
     *
     * @return
     */
    public static InnerSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

## 双重校验式

​双重校验在没有加volatile修饰符时是线程不安全的，多个线程之间彼此看到不到最新的变量值。volatile保证线程之间内存可见性。这种写法虽然用了同步锁，但只有第一次加载时会加锁，因此不存在性能问题。

```java
public class DoubleCheckSingleton {

    /**
     * volatile修饰对象，保证线程间内存可见性的问题
     */
    private volatile static DoubleCheckSingleton instance;

    private DoubleCheckSingleton() {
    }

    public static DoubleCheckSingleton getInstance() {
        //没有加volatile修饰符时，线程不安全，过程如下
        //1、线程AB同时到达这里，此时instance == null
        if (instance == null) {
            //2、只有一个线程能进入同步方法，假设A进入，线程B等待
            synchronized (DoubleCheckSingleton.class) {
                //3、线程A先进入，new对象后退出返回实例
                //4、线程B后进入，因为线程A实例化后的类，对线程B不可见，此时instance == null，因 此线程B也进行new对象后返回实例
                if (instance == null) {
                    instance = new DoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}
```

## 枚举式

枚举式单例可以说是最简洁、最高效的单例模式，用最少的代码既保证实例唯一，又保证线程安全；缺点只有一个：它无法被继承。

```java
public enum EnumSingleton {

    /**
     * 枚举变量
     */
    INSTANCE;

    public void method(){

    }
}
```

## ThreadLocal式

很多时候，我们都在考虑线程间变量共享，而ThreadLocal刚好相反，它为每个线程提供一份独立的副本，隔离线程之间对同一变量访问的冲突，互不影响。

```java
public class ThreadLocalSingleton {
    /**
     * ThreadLocal为每个线程提供了副本，互不影响
     */
    private static final ThreadLocal<ThreadLocalSingleton> TL_SINGLETON = new ThreadLocal<ThreadLocalSingleton>() {
        @Override
        protected ThreadLocalSingleton initialValue() {
            return new ThreadLocalSingleton();
        }
    };

    private ThreadLocalSingleton() {

    }

    public static ThreadLocalSingleton getInstance() {
        return TL_SINGLETON.get();
    }
}
```

## CAS式

要获得唯一的实例，可以用利用AtomicReference的原子性，利用底层的CAS来实现

```java
public class CASSingleton {

    private static AtomicReference<CASSingleton> instance = new AtomicReference<>();

    private CASSingleton() {

    }

    public static CASSingleton getInstance() {
        //自旋，直到唯一实例被创建
        for (; ; ) {
            CASSingleton singleton = instance.get();
            if (null == singleton) {
                singleton = new CASSingleton();
                if (instance.compareAndSet(null, singleton)) {
                    return singleton;
                }
            } else {
                return singleton;
            }

        }
    }
}
```

