---
title: 常用设计模式 - 代理模式
date: 2018-12-30 22:08:07
categories: 
- 设计模式
tags: #文章标签
- 设计模式
- 静态代理
- 动态代理
---
代理模式是JAVA常用的设计模式之一，代理模式不直调用代理对象，而是通过对象的代理类来处理，好比是中介、黄牛、经纪人，代理模式又分为静态代理和动态代理。

代理对象：面向调用者，在调用者和被代理对象之间作为隔离层加以控制，可以增强被代理对象的方法。

被代理对象：真正的执行者，需要对代理对象暴露

<!-- more -->

# 静态代理

何为静态？其实就是在编码阶段，写好代理类，然后编译运行，在程序运行前，代理类已经存在。

以学生小明找黄牛购票为例：

```java
public interface Student {
    void buy();
}
```

小明：

```java
public class XiaoMing implements Student {
    @Override
    public void buy() {
        System.out.println("我是学生小明，我要一张去上海的票");
    }
}
```

黄牛：

```java
public class HuangNiu implements Student {

    private Student target;

    //代理类实例化时需要传入被代理类实例的引用
    public HuangNiu(Student student) {
        this.target = student;
    }

    @Override
    public void buy() {
        System.out.println("我是黄牛，你要什么票？");
        System.out.println("------------");
        //调用被代理类的方法
        this.target.buy();
        System.out.println("------------");
    }
}
```

测试类：

```java
public class StaticProxyTest {

    public static void main(String[] args) {
        Student xiaoMing = new XiaoMing();
        HuangNiu huangNiu = new HuangNiu(xiaoMing);
        huangNiu.buy();
    }
}
```

运行结果：

```shell
我是黄牛，你要什么票？
------------
我是学生小明，我要一张去上海的票
------------
```

# 动态代理

相对于静态代理，动态代理的代理类是在运行时生成，动态代理在实现上又有两种，分别是jdk动态代理和cglib动态代理。

## JDK动态代理

JDK动态代理要求被代理对象**必须实现接口**，其原理是代理对象实现该接口的方法，同时调用被代理对象的方法。将生成后的代理对象，强制转换为接口被调用者调用。还是以小明和黄牛为例：

小明，实现学生接口的buy方法

```java
public class XiaoMing implements Student {

    @Override
    public void buy() {
        System.out.println("我是学生，我要买票去上海的硬座");
    }
}
```

黄牛，作为小明的代理实现InvocationHandler

```java
public class HuangNiu implements InvocationHandler {

    private Student target;

    /**
     * 生成代理对象
     *
     * @param target
     * @return
     */
    public Object getInstance(Student target) {
        this.target = target;
        Class clazz = target.getClass();
        return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("我是黄牛，你要什么票?");
        System.out.println("--------------");
        //代理对象持有被代理对象实例的引用，通过反射调用目标方法
        method.invoke(target, args);
        System.out.println("--------------");
        return null;
    }
```

测试类：

```java
public class ProxyTest {

    public static void main(String[] args) {
        /**
         * 实例化代理类时调用getInstance方法传入了小明的实例，生成代理类==>黄牛，强制转换为Student
         * 接口，因此实际上是由黄牛去执行买票操作；
         */
        Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing());
        huangniu.buy();
    }
}
```

运行结果：

```shell
 我是黄牛，你要什么票?
 --------------
 我是学生，我要买票去上海的硬座
 --------------
```

HuangNiu类没有直接实现Person接口，而是通过反射生成字节码文件的方式，动态生成真正的代理类。

## Cglib动态代理

与JDK动态代理不同的是，cglib代理不强制被代理类实现接口，它是通过生成代理类的子类，并重写代理类方法来实现的，所以代理类不能用final修饰，还是以小明和黄牛为例：

小明：

```java
public class XiaoMing {

    public void buy() {
        System.out.println("我是学生，我要买票去上海的硬座");
    }
}
```

黄牛：

```java
//MethodInterceptor是cglib
public class HuangNiu implements MethodInterceptor {

    public Object getInstance(Class clazz){
        //cglib封装的高性能的代码生成库
        Enhancer enhancer = new Enhancer();
        //设置父类
        enhancer.setSuperclass(clazz);
        //回调当前实例
        enhancer.setCallback(this);
        return enhancer.create();
    }


    @Override
    public Object intercept(Object target, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("我是黄牛，你要什么票?");
        System.out.println("--------------");
        //注意，这里如果用invoke会造成死循环，因为代理类是被代理类的子类，如果调用invokeSuper方法，
        //会调用父类的方法，而invoke会重复进入当前代理类的方法，造成死循环
        methodProxy.invokeSuper(target,objects);
        System.out.println("--------------");
        return null;
    }
}
```

cglib动态代理并没有像JDK动态代理那样，直接持有代理类实例的引用，那么intercept方法的第一个参数Object是怎么生成？根据类加载的顺序，实例化子类前，必先实例化其父类

实例化 ChildClass ==> new FatherClass ==> new ChildClass；

测试类：

```java
public class CglibProxyTest {

    public static void main(String[] args) {
        XiaoMing p = (XiaoMing) new HuangNiu().getInstance(XiaoMing.class);
        p.buy();
    }
}
```

运行结果：

```shell
 我是黄牛，你要什么票?
 --------------
 我是学生，我要买票去上海的硬座
 --------------
```



## 应用场景

代理模式随处可见，最常见的是spring的AOP，比如spring的事务代理，在对数据进行操作时会涉及事务开启、事务提交、事务回滚等操作，简化的数据操作模型如下图：

![](简单事务模型.png)

业务场景中存在大量的事务操作（红色），而这些往往不是开发者的关注点，开发者更注重于业务逻辑（蓝色）。因此代理模式可以增强业务逻辑代码，在事务执行前开启事务，在事务执行后进行回滚/提交/关闭。

# 总结

1. 静态代理需要编写代理类，动态代理不需要；
2. 静态代理在无需修改被代理类的前提下，对代理类进行增强和扩展，但是静态代理只能对一个被代理类服务，如果被代理类过多，就会产生相应数量的代理类实现与被代理类一致的接口，产生冗余，不易维护；
3. JDK动态代理只要求代理类实现InvocationHandler接口，被代理类实现业务接口即可。
4. 静态代理编译时生成的class的性能高于JDK动态代理通过反射生成class；
5. cglib不要求被代理类实现接口，而是通过继承的方式实现，因此类和方法都不能用final修饰。cglib底层用高性能的字节码生成器，性能高于反射。

