---
title: 单例的破坏和防御
date: 2019-01-06 18:14:25
tags:
- 单例
categories:
- 设计模式
---

上篇介绍了几种单例的写法，这一片介绍如何破坏单例以及防御

<!-- more -->

# 反射破坏

思考一个问题，单例真的安全吗？以懒汉式单例为例，将构造器声明为private，是不是就万无一失，无法用构造器对其实例化？在Java的特性——反射面前，私有构造器也不起作用了。

```java
public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
    LazySingleton singleton1 = LazySingleton.getInstance();
    LazySingleton singleton2 = getInstanceByConstruct();
    System.out.println("singleton1 == singleton2 :" + (singleton1 == singleton2));
}


/**
 * 通过反射实例化对象
 * @return
 * @throws NoSuchMethodException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws InstantiationException
 */
public static LazySingleton getInstanceByConstruct() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
    Class clazz = LazySingleton.class;
    Constructor constructor = clazz.getDeclaredConstructor();
    //访问权限
    constructor.setAccessible(true);
    return  (LazySingleton) constructor.newInstance();
}
```

运行结果

```
singleton1 == singleton2 :false 
```

通过反射成功实例化对象，单例破坏，那么要如何防御？

# 防御反射破坏

既然是通过构造器实例化，自然而然可以想到，可以在构造器里防止单例被破坏。

```java
private LazySingleton() {
    //加上判断，防止通过构造器被再次实例化
    if(null != instance){
        throw new RuntimeException("单例已存在");
    }
}
```

再运行一次main方法

```shell
Exception in thread "main" java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
	at com.cjluo.chapter1.singleton.test.BreakSingleton.getInstanceByConstruct(BreakSingleton.java:35)
	at com.cjluo.chapter1.singleton.test.BreakSingleton.main(BreakSingleton.java:17)
Caused by: java.lang.RuntimeException: 单例已存在
	at com.cjluo.chapter1.singleton.LazySingleton.<init>(LazySingleton.java:18)
	... 6 more
```

抛出异常，实例化失败，提示单例已存在，成功防御通过反射对单例的破坏。但是，单例安全了吗？还可以通过其他方式破坏吗？当然可以，接下来介绍如何通过拷贝对象破坏单例。

# 对象拷贝破坏

前面介绍了原型模式和深拷贝，这里就通过深拷贝破坏单例

```java
public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        LazySingleton singleton1 = LazySingleton.getInstance();
        LazySingleton singleton3 = deepClone(singleton1);
        System.out.println("singleton1 == singleton2 :" + (singleton1 == singleton3));
    }
/**
 * 深拷贝
 * @param singleton
 * @return
 */
public static LazySingleton deepClone(LazySingleton singleton) {
    ByteArrayOutputStream bos = null;
    ObjectOutputStream oos = null;

    ByteArrayInputStream bis;
    ObjectInputStream ois;

    try {
        bos = new ByteArrayOutputStream();
        oos = new ObjectOutputStream(bos);
        oos.writeObject(singleton);

        bis = new ByteArrayInputStream(bos.toByteArray());
        ois = new ObjectInputStream(bis);

        return (LazySingleton) ois.readObject();

    } catch (IOException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } finally {
        try {
            bos.close();
            oos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    return null;
}
```

运行结果

```shell
singleton1 == singleton2 :false
```

对象被序列化、反序列化后生成的实例，已经破坏了单例。这种方式的破坏如何防御呢？先从readObject()源码分析

```java
/**
 * ObjectInputStream.readObject
 * 
 */
public final Object readObject() throws IOException, ClassNotFoundException
{
    if (enableOverride) {
        return readObjectOverride();
    }

    // if nested read, passHandle contains handle of enclosing object
    int outerHandle = passHandle;
    try {
        //进入readObject0方法
        Object obj = readObject0(false);
        handles.markDependency(outerHandle, passHandle);
        ClassNotFoundException ex = handles.lookupException(passHandle);
        if (ex != null) {
            throw ex;
        }
        if (depth == 0) {
            vlist.doCallbacks();
        }
        return obj;
    } finally {
        passHandle = outerHandle;
        if (closed && depth == 0) {
            clear();
        }
    }
}


private Object readObject0(boolean unshared) throws IOException {
        boolean oldMode = bin.getBlockDataMode();
        if (oldMode) {
            int remain = bin.currentBlockRemaining();
            if (remain > 0) {
                throw new OptionalDataException(remain);
            } else if (defaultDataEnd) {
                /*
                 * Fix for 4360508: stream is currently at the end of a field
                 * value block written via default serialization; since there
                 * is no terminating TC_ENDBLOCKDATA tag, simulate
                 * end-of-custom-data behavior explicitly.
                 */
                throw new OptionalDataException(true);
            }
            bin.setBlockDataMode(false);
        }

        byte tc;
        while ((tc = bin.peekByte()) == TC_RESET) {
            bin.readByte();
            handleReset();
        }

        depth++;
        try {
        	//判断对象类型
            switch (tc) {
                case TC_NULL:
                    return readNull();

                case TC_REFERENCE:
                    return readHandle(unshared);

                case TC_CLASS:
                    return readClass(unshared);

                case TC_CLASSDESC:
                case TC_PROXYCLASSDESC:
                    return readClassDesc(unshared);
                //字符串
                case TC_STRING:
                case TC_LONGSTRING:
                    return checkResolve(readString(unshared));
                //数组
                case TC_ARRAY:
                    return checkResolve(readArray(unshared));
                //枚举
                case TC_ENUM:
                    return checkResolve(readEnum(unshared));
                //对象
                case TC_OBJECT:
                    return checkResolve(readOrdinaryObject(unshared));

                case TC_EXCEPTION:
                    IOException ex = readFatalException();
                    throw new WriteAbortedException("writing aborted", ex);

                case TC_BLOCKDATA:
                case TC_BLOCKDATALONG:
                    if (oldMode) {
                        bin.setBlockDataMode(true);
                        bin.peek();             // force header read
                        throw new OptionalDataException(
                            bin.currentBlockRemaining());
                    } else {
                        throw new StreamCorruptedException(
                            "unexpected block data");
                    }

                case TC_ENDBLOCKDATA:
                    if (oldMode) {
                        throw new OptionalDataException(true);
                    } else {
                        throw new StreamCorruptedException(
                            "unexpected end of block data");
                    }

                default:
                    throw new StreamCorruptedException(
                        String.format("invalid type code: %02X", tc));
            }
        } finally {
            depth--;
            bin.setBlockDataMode(oldMode);
        }
    }
```

反序列化时，会先判断对象的类型，String、Array、Object等，如果是Object，进入readOrdinaryObject方法读取对象。

```java
        if (bin.readByte() != TC_OBJECT) {
            throw new InternalError();
        }
        //读取对象的属性、方法，后面会用到
        ObjectStreamClass desc = readClassDesc(false);
        desc.checkDeserialize();
```

首先，readClassDesc会读取对象的属性和几个特殊方法（writeObjectMethod、readObjectMethod、readObjectNoDataMethod、writeReplaceMethod、readResolveMethod），紧接着再次判断对象类型是否为普通的对象，然后进行实例化。

```java
   Class<?> cl = desc.forClass();
        if (cl == String.class || cl == Class.class
                || cl == ObjectStreamClass.class) {
            throw new InvalidClassException("invalid class descriptor");
        } 

   Object obj;
        try {
            //对象实例化
            obj = desc.isInstantiable() ? desc.newInstance() : null;
        } catch (Exception ex) {
            throw (IOException) new InvalidClassException(
                desc.forClass().getName(),
                "unable to create instance").initCause(ex);
        }
```

接下来的几行代码是各种校验，重点的代码在这里

```java
       //重点在这行，hasReadResolveMethod判断是否有readResolve方法
        if (obj != null &&
            handles.lookupException(passHandle) == null &&
            desc.hasReadResolveMethod())
        {
            //调用ReadResolve方法
            Object rep = desc.invokeReadResolve(obj);
            if (unshared && rep.getClass().isArray()) {
                rep = cloneArray(rep);
            }
            if (rep != obj) {
                handles.setObject(passHandle, obj = rep);
            }
        }
```

读取readResolve方法

```java
Object invokeReadResolve(Object obj)
    throws IOException, UnsupportedOperationException
{
    requireInitialized();
    if (readResolveMethod != null) {
        try {
            return readResolveMethod.invoke(obj, (Object[]) null);
        } catch (InvocationTargetException ex) {
            Throwable th = ex.getTargetException();
            if (th instanceof ObjectStreamException) {
                throw (ObjectStreamException) th;
            } else {
                throwMiscException(th);
                throw new InternalError(th);  // never reached
            }
        } catch (IllegalAccessException ex) {
            // should not occur, as access checks have been suppressed
            throw new InternalError(ex);
        }
    } else {
        throw new UnsupportedOperationException();
    }
}
```

# 防御拷贝破坏

如果我们要防止单例被深拷贝破坏，关键点就在于对象是否有readResolve方法。在LazySingleton加上该方法。

```java
private Object readResolve(){
    return instance;
}
```

再次运行

```java
singleton1 == singleton2 :true
```

# 无法破坏的单例

前文有提到一种单例写法，是很完美的单例——枚举单例，它既保证线程安全，又不需要任何同步加锁操作，除此之外，它可以防御以上两种单例的破坏，因为JDK在底层实现上就做了防御处理。

```java
public enum EnumSingleton {

    /**
     * 枚举实例
     */
    INSTANCE;

    EnumSingleton() {
    }

    public void method(){

    }
}
```

通过反射获取构造器实例化单例

```java
   public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        EnumSingleton enumSingleton = EnumSingleton.INSTANCE;
        EnumSingleton enumSingleton1 = getInstance();
        System.out.println("enumSingleton == enumSingleton1 :" + (enumSingleton == enumSingleton1));

    }    

	public static EnumSingleton getInstance() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        Class clazz = EnumSingleton.class;
        Constructor constructor = clazz.getDeclaredConstructor(String.class,int.class);
        //访问权限
        constructor.setAccessible(true);
        return  (EnumSingleton) constructor.newInstance();
    }
```

运行结果，无法通过反射实例化枚举对象

```java
Exception in thread "main" java.lang.IllegalArgumentException: Cannot reflectively create enum objects
	at java.lang.reflect.Constructor.newInstance(Constructor.java:416)
	at com.cjluo.chapter1.singleton.test.BreakSingleton.getInstance(BreakSingleton.java:49)
	at com.cjluo.chapter1.singleton.test.BreakSingleton.main(BreakSingleton.java:22)
```

对应的源码

```java
@CallerSensitive
public T newInstance(Object ... initargs)
    throws InstantiationException, IllegalAccessException,
           IllegalArgumentException, InvocationTargetException
{
    if (!override) {
        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
            Class<?> caller = Reflection.getCallerClass();
            checkAccess(caller, clazz, null, modifiers);
        }
    }
    //对class类型进行校验，如果是枚举，直接抛出异常
    if ((clazz.getModifiers() & Modifier.ENUM) != 0)
        throw new IllegalArgumentException("Cannot reflectively create enum objects");
    ConstructorAccessor ca = constructorAccessor;   // read volatile
    if (ca == null) {
        ca = acquireConstructorAccessor();
    }
    @SuppressWarnings("unchecked")
    T inst = (T) ca.newInstance(initargs);
    return inst;
}
```

JDK底层将反射实例化的类型做了限制，排除了枚举。因此这种方式无法破坏枚举单例，那么通过深拷贝的方式呢？（深拷贝代码与上述相似，不再列举）

```java
 public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        EnumSingleton enumSingleton = EnumSingleton.INSTANCE;
        EnumSingleton enumSingleton1 = deepClone(enumSingleton);
        System.out.println("enumSingleton == enumSingleton1 :" + (enumSingleton == enumSingleton1));

    }
```

运行结果：

```she&#39;l&#39;l
enumSingleton == enumSingleton1 :true
```

通过对象拷贝，不需要额外处理，枚举的单例也不会被破坏。分析源码readObject0方法

```java
private Object readObject0(boolean unshared) throws IOException {
        //省略...
        depth++;
        try {
        	//判断对象类型
            switch (tc) {
                //省略...
                //枚举
                case TC_ENUM:
                    return checkResolve(readEnum(unshared));
                //对象
                case TC_OBJECT:
                    return checkResolve(readOrdinaryObject(unshared));
                default:
                    throw new StreamCorruptedException(
                        String.format("invalid type code: %02X", tc));
            }
        } finally {
            depth--;
            bin.setBlockDataMode(oldMode);
        }
    }
```

readEnum，返回枚举实例

```java
private Enum<?> readEnum(boolean unshared) throws IOException {
    if (bin.readByte() != TC_ENUM) {
        throw new InternalError();
    }

    ObjectStreamClass desc = readClassDesc(false);
    if (!desc.isEnum()) {
        throw new InvalidClassException("non-enum class: " + desc);
    }

    int enumHandle = handles.assign(unshared ? unsharedMarker : null);
    ClassNotFoundException resolveEx = desc.getResolveException();
    if (resolveEx != null) {
        handles.markException(enumHandle, resolveEx);
    }

    String name = readString(false);
    Enum<?> result = null;
    Class<?> cl = desc.forClass();
    if (cl != null) {
        try {
            @SuppressWarnings("unchecked")
            //获取枚举实例
            Enum<?> en = Enum.valueOf((Class)cl, name);
            result = en;
        } catch (IllegalArgumentException ex) {
            throw (IOException) new InvalidObjectException(
                "enum constant " + name + " does not exist in " +
                cl).initCause(ex);
        }
        if (!unshared) {
            handles.setObject(enumHandle, result);
        }
    }

    handles.finish(enumHandle);
    passHandle = enumHandle;
    return result;
}
```

与readOrdinaryObject不同的是，Object对象通过newInstance实例化新的对象，而枚举对象通过Enum.valueOf获取的还是枚举对象自身，readEnum不会继续后面的resolveMethod判断，直接返回当前枚举实例。因此，枚举对象的实例，即使通过深拷贝，也始终是它自身。

# 总结

1、普通的单例可以通过反射、深拷贝破坏

2、普通的单例防御单例破坏，需在构造器中加校验，在对象中加以下方法，返回当前实例

```java
private Object readResolve(){
    return instance;
}
```

3、枚举单例无法被反射和深拷贝破坏