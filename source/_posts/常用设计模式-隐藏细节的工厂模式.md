---
title: 常用设计模式-隐藏细节的工厂模式
date: 2018-12-28 18:33:57
tags:
- 设计模式
- 工厂模式
category:
- 设计模式
---

如果你要一台宝马，带上钱，去宝马4S店，就可以买到宝马；

如果你要一台奔驰，带上钱，去奔驰4S点，就可以买到奔驰；

如果你要一台奥迪……

你需要什么，就给你什么，而不需要关心它的细节，这就是工厂模式，工厂模式负责生产调用者需要的“产品”（实例）。通常所说的工厂模式，有这三种：

1. 简单工厂（simple factory）
2. 工厂方法（factory method）
3. 抽象工厂（abstract factory）

<!-- more -->

逐一分析，先定义Car接口

```java
public interface Car {

    String getName();
}
```

再分别定义宝马、奔驰、奥迪三个“产品”

```java
//宝马
public class Bmw implements Car {
    @Override
    public String getName() {
        return "Bmw";
    }
}
```

```java
//奥迪
public class Audi implements Car {
    @Override
    public String getName() {
        return "Audi";
    }
}
```

```java
//奔驰
public class Benz implements Car {
    @Override
    public String getName() {
        return "Benz";
    }
}
```

# 简单工厂

定义SimpleFactory：

```java
public class SimpleFactory {

    public static Car getCar(String name) {
        if ("bmw".equalsIgnoreCase(name)) {
            return new Bmw();
        } else if ("benz".equalsIgnoreCase(name)) {
            return new Benz();
        } else if ("audi".equalsIgnoreCase(name)) {
            return new Audi();
        }else{
            System.out.println("没有你要的车！");
            return null;
        }
    }
}
```

测试类：

```java
public class SimpleFactoryTest {

    public static void main(String[] args) {
        Car car = SimpleFactory.getCar("benz");
        System.out.println(car.getName());
        
        car = SimpleFactory.getCar("bmw");
        System.out.println(car.getName());
        
        car = SimpleFactory.getCar("audi");
        System.out.println(car.getName());
    }
}
```

测试结果：

```shell
Benz
Bmw
Audi
```

简单工厂简单粗暴，就像一个强大的汽车制造商，生产BBA甚至更多品牌的汽车，客户想要什么车，工厂就生产什么车，如果生产不了，返回null。

我们思考一下，现实中有没有这种工厂，既可以生产奔驰，又可以生产宝马和奥迪？不存在的。一般是奥迪工厂生产奥迪、奔驰工厂生产奔驰，宝马工厂生产宝马。。。这时候就要对简单工厂进行改造，产生了工厂方法模式。

# 工厂方法

首先要有一个汽车工厂接口，这个接口定义了一套汽车生产规范和流程，所有的汽车制造商都要按照这个规范和流程生产汽车。

```java
//汽车工厂
public interface CarFactory {
    Car getCar();
}
```

然后各制造商按照这个规范生产汽车，具体怎么造，各厂商自己去实现细节。

宝马工厂

```java
//宝马工厂
public class BmwFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new Bmw();
    }
}
```

奥迪工厂

```java
//奥迪工厂
public class AudiFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new Audi();
    }
}
```

奔驰工厂

```java
//奔驰工厂
public class BenzFactory implements CarFactory {
    @Override
    public Car getCar() {
        return new Benz();
    }
}
```

客户需要哪个品牌的汽车，就去找哪个工厂生产，测试类：

```java
public class FunFactoryTest {

    public static void main(String[] args) {
        Car car = new BmwFactory().getCar();
        System.out.println(car.getName());

        car = new BenzFactory().getCar();
        System.out.println(car.getName());

        car = new AudiFactory().getCar();
        System.out.println(car.getName());
    }
}
```

（运行结果同简单工厂模式，就不列举了）

方法工厂不同于简单工厂之处在于，它做了细分，把大而全的工厂拆解成多个工厂生产不同的“产品”，职责清晰，目标明确，但是方法工厂缺点在于，客户要自己找到这个工厂才能得到想要的车，实际上这是不合理的，因此结合简单工厂和方法工厂，又衍生出了抽象工厂。

# 抽象工厂

试想一下，客户要某个品牌的车，还得自己去找对应品牌的工厂，这种需要客户介入的行为是很不友好的，假如有一个经销商，它负责对客户收单，然后让对应的工厂去生产客户想要的车，这就完美解决了以上问题。

抽象工厂类：

```java
//结合了简单工厂和方法工厂的抽象工厂类
public abstract class AbstractCarFactory {

    //定制一个造车流程和规范，让各造车厂商去实现
    protected abstract Car getCar();

    //从客户获取订单，从对应的工厂获取客户想要的车
    public Car getCar(String name) {
        if ("bmw".equalsIgnoreCase(name)) {
            return new BmwFactory().getCar();
        } else if ("benz".equalsIgnoreCase(name)) {
            return new BenzFactory().getCar();
        } else if ("audi".equalsIgnoreCase(name)) {
            return new AudiFactory().getCar();
        } else {
            System.out.println("没有你要的车");
            return null;
        }
    }
}
```

各造车工厂

```java
//奥迪工厂
public class AudiFactory extends AbstractCarFactory {
    @Override
    protected Car getCar() {
        return new Audi();
    }
}
```

```java
//奔驰工厂
public class BenzFactory extends AbstractCarFactory {
    @Override
    protected Car getCar() {
        return new Benz();
    }
}
```

```java
//宝马工厂
public class BmwFactory extends AbstractCarFactory {
    @Override
    protected Car getCar() {
        return new Bmw();
    }
}
```

因为抽象类无法实例化，通常都有一个默认实现，定义一个默认的工厂

```java
//默认工厂
public class DefaultCarFactory extends AbstractCarFactory {
    //指定默认的工厂为奥迪工厂
    private AudiFactory factory = new AudiFactory();

    @Override
    protected Car getCar() {
        return factory.getCar();
    }
}
```

测试类：

```java
public class AbstractCarFactoryTest {

    public static void main(String[] args) {
        AbstractCarFactory factory = new DefaultCarFactory();
        Car car = factory.getCar("bmw");
        if(null != car){
            System.out.println(car.getName());
        }
    }
}
```

# 应用场景

spring中bean的创建就使用了工厂模式，各种bean工厂都实现了BeanFactory接口，调用者只需要输入beanName或者id，工厂就可以生成所需要的Bean。

网络传输协议的选择，调用者只需要描述需要什么协议，比如HTTP/TCP/POP3，协议工厂便可以生产对应的实现。

# 总结

1. 工厂模式将类的实例化过程完全隐藏，调用者只需要传入类名，就可以获得所需的实例，如果在代码中存在大量的new实例化对象，万一改了类的构造方法，对代码的破坏简直是灾难，必须将所有相关的代码一一修改，如果你用工厂模式，就可以避免这种事发生。
2. 简单工厂对类实例化的简单封装，它的缺点是不利于拓展，工厂并非真的大而全，如果要增加一个工厂，哪怕只是简单的修改if/else代码块，也是违背面向对象设计的**开闭原则**;
3. 工厂方法对简单工厂进行了抽象，每个产品都由单独的工厂来创建，要新增产品，只要新增这个产品的工厂，完全遵循对修改关闭，对扩展开放的原则；但是工厂方法需要调用者明确哪个工厂生产什么并且显式的调用，并没有完全解耦；
4. 抽象工厂又是对工厂方法的进一步封装，同类产品由同一工厂生产，它的缺点是抽象工厂如果存在多个产品，子类必须实现所有的抽象方法，相当于开了整套的流水线。