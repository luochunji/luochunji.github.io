---
title: 几种序列化方式的性能比较
date: 2019-02-02 09:56:51
tags:
- 序列化
- json
- hessian
- kryo
- messagepack
- protobuf
categories:
- 性能
- 序列化
---

序列化是（Serialization）是将对象的状态信息转换为可以存储或传输的形式的过程。 在序列化期间，对象将其当前状态写入到临时或持久性存储区。 以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。在分布式系统中，序列化是很重要的，直接关系数据的传输大小和效率，这里比较几种常见的序列化工具（框架）之间的性能差异。

<!-- more -->

# JAVA原生序列化

![](Java_logo.png)

JDK自带的序列化，对象必须实现Serializable接口，通过ObjectOutputStream输出二进制数据，反序列化通过ObjectInputStream生成目标对象

```java
public class JavaSerializable extends AbstractSerializableByte {

	public <T> JavaSerializable(T object) {
		super(object);
	}

	@Override
	public <T> byte[] serializableByte(T object) {
		ByteArrayOutputStream bos = null;
		ObjectOutputStream oos = null;

		try {
			bos = new ByteArrayOutputStream();
			oos = new ObjectOutputStream(bos);
			oos.writeObject(object);
			oos.flush();
			return bos.toByteArray();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (bos != null) {
					bos.close();
				}
				if (oos != null) {
					oos.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return null;
	}

	@Override
	public <T> T deSerializable(Class<T> clazz, byte[] byteIn) {
		ByteArrayInputStream bis = null;
		ObjectInputStream ois = null;
		try {
			bis = new ByteArrayInputStream(byteIn);
			ois = new ObjectInputStream(bis);
			return (T) ois.readObject();
		} catch (IOException e) {
			e.printStackTrace();
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		} finally {
			try {
				if (null != bis) {
					bis.close();
				}
				if (null != ois) {
					ois.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return null;
	}
}
```

# JSON工具

JSON是一种轻量级的数据交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象，类似xml，Json比xml更小、更快更容易解析，JSON序列化框架有很多，主流的有下面三种：Gson、fastJson和Jackson

## fastJson

![](fastjson_logo.jpg)

fastJson是阿里巴巴的开源JSON解析库（[github传送门](https://github.com/alibaba/fastjson)），在企业中应用广泛，首先要导入依赖

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.47</version>
</dependency>
```

```java
public class FastJsonSerializable extends AbstractSerializableString {

	public <T> FastJsonSerializable(T object) {
		super(object);
	}

	@Override
	public <T> void doSerializable(T object) {
		String str = serializableStr(object);
		deSerializable((Class<T>) object.getClass(), str);
	}

	@Override
	public <T> String serializableStr(T object) {
		return JSONObject.toJSONString(object);
	}

	@Override
	public <T> T deSerializable(Class<T> clazz, String strIn) {
		return JSONObject.parseObject(strIn, clazz);
	}
}
```

## Gson

![](gson-mini-logo.jpg)

Gson是Google公司发布的一个开源的Java库（[github传送门](https://github.com/google/gson)），也是一个高效的JAVA对象序列化、反序列化框架。

引入依赖

```xml
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.5</version>
</dependency>
```

实现上和fastJson没有太大差异

```java
public class GsonSerializable extends AbstractSerializableString {

	private Gson gson;

	public <T> GsonSerializable(T object) {
		super(object);
	}

	@Override
	protected <T> void init(T object) {
        //初始化
		gson = new Gson();
	}

	@Override
	public <T> String serializableStr(T object) {
		return gson.toJson(object);
	}

	@Override
	public <T> T deSerializable(Class<T> clazz, String strIn) {
		return gson.fromJson(strIn, clazz);
	}
}
```

## Jackson

![](jackson_images.png)

Jackson（[github传送门](https://github.com/codehaus/jackson)）也是java语言实现的开源工具，它是Spring中Json的默认实现，虽然多年未维护了，但依旧使用广泛。

引入依赖

```xml
<dependency>
    <groupId>org.codehaus.jackson</groupId>
    <artifactId>jackson-mapper-asl</artifactId>
    <version>1.9.13</version>
</dependency>
```

```java
public class JacksonSerializable extends AbstractSerializableByte {

	private ObjectMapper mapper;

	public <T> JacksonSerializable(T object) {
		super(object);
	}

	@Override
	public <T> void init(T object) {
        //初始化
		mapper = new ObjectMapper();
	}

	@Override
	public <T> byte[] serializableByte(T object) {
		try {
			return mapper.writeValueAsBytes(object);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	@Override
	public <T> T deSerializable(Class<T> clazz, byte[] byteIn) {
		try {
			return mapper.readValue(byteIn,clazz);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

}
```

# Hessian

Hessian（[官网传送门](http://hessian.caucho.com/)）是一个基于二进制的协议，Hessian支持很多种语言，例如Java、python、c++,、net/c#、D、Erlang、PHP、Ruby、object-c等，它的序列化和反序列化也是非常高效，与Java原生序列化一样，被序列化/反序列化的对象也必须实现Serializable接口，实现代码的写法也很像Java原生序列化。

引入依赖

```xml
<dependency>
    <groupId>com.caucho</groupId>
    <artifactId>hessian</artifactId>
    <version>4.0.51</version>
</dependency>
```

```java
public class HessianSerializable extends AbstractSerializableByte {

	public <T> HessianSerializable(T object){
		super(object);
	}

	@Override
	public <T> byte[] serializableByte(T object) {
		ByteArrayOutputStream bos = null;
		Hessian2Output ho = null;
		try {
			bos = new ByteArrayOutputStream();
			ho = new Hessian2Output(bos);
			ho.writeObject(object);
			ho.flush();
			return bos.toByteArray();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (null != bos) {
					bos.close();
				}
				if (null != ho) {
					ho.close();
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return null;
	}

	@Override
	public <T> T deSerializable(Class<T> clazz, byte[] byteIn) {
		return deSerializable(byteIn);
	}

	private  <T> T deSerializable(byte[] byteIn) {
		ByteArrayInputStream bis = new ByteArrayInputStream(byteIn);
		Hessian2Input hInput = new Hessian2Input(bis);
		try {
			return (T) hInput.readObject();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				bis.close();
				hInput.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return null;
	}
}
```

# Kryo

![](kyro.jpg)

Kryo是一个快速高效的Java序列化框架（[github传送门](https://github.com/EsotericSoftware/kryo)），旨在提供快速、高效和易用的API。无论文件、数据库或网络数据Kryo都可以随时完成序列化。Kryo还可以执行自动深拷贝（克隆）、浅拷贝（克隆）。这是对象到对象的直接拷贝，而不是对象->字节->对象的拷贝。

引入依赖

```xml
<dependency>
    <groupId>com.esotericsoftware</groupId>
    <artifactId>kryo</artifactId>
    <version>4.0.2</version>
</dependency>
```

```java
public class KryoSerializable extends AbstractSerializableByte {

	private Kryo kryo;

	public <T> KryoSerializable(T object) {
		super(object);
	}

	@Override
	public <T> void init(T object) {
		kryo = new Kryo();
		kryo.setReferences(false);
		//无需强制注册
		kryo.setRegistrationRequired(false);
	}

	@Override
	public <T> byte[] serializableByte(T object) {
		ByteArrayOutputStream bos = null;
		Output output = null;
		try {
			bos = new ByteArrayOutputStream();
			output = new Output(bos);
			kryo.writeObject(output, object);
		} finally {
			try {
				bos.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			output.close();
		}
		return bos.toByteArray();
	}

	@Override
	public <T> T deSerializable(Class<T> clazz, byte[] byteIn) {
		ByteArrayInputStream bis = new ByteArrayInputStream(byteIn);
		Input input = new Input(bis);
		try {
			return kryo.readObject(input, clazz);
		} finally {
			try {
				bis.close();
				input.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}
```

# MessagePack

![](messagePack.png)

It's like JSON.but fast and small. —— messagePack官网（[传送门](https://msgpack.org/)）的定义，一句话足以说明它的特点

引入依赖

```xml
<dependency>
    <groupId>org.msgpack</groupId>
    <artifactId>msgpack</artifactId>
    <version>0.6.12</version>
</dependency>
```

messagepack要求序列化的对象上需要加@Message注解

```java
@Message
public class User implements Serializable {
    //...省略
}
```

实现

```java
public class MessagePackSerializable extends AbstractSerializableByte {

	private MessagePack msgpack;

	public <T> MessagePackSerializable(T object) {
		super(object);
	}

	@Override
	public <T> void init(T object) {
		msgpack = new MessagePack();
	}

	@Override
	public <T> byte[] serializableByte(T object) {
		try {
			return msgpack.write(object);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}


	@Override
	public <T> T deSerializable(Class<T> clazz, byte[] byteIn) {
		try {
			return msgpack.read(byteIn, clazz);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}
}
```

# Protobuf

![](protobuf.png)

protobuf（Protocol Buffers，[官网传送门](https://developers.google.com/protocol-buffers/)）是由Google公司发布的数据交换格式，提供跨语言、跨平台的序列化和反序列化实现，底层由C++实现，其他平台使用时必须使用protocol compiler进行预编译生成protoc二进制文件，原生的protobuf演示略显麻烦，这里只是为了做性能测试，因此使用百度公司对protobuf二次封装的API:**jprotobuf**（[github传送门](https://github.com/jhunters/jprotobuf)）

jprotobuf是针对Java程序开发一套简易类库，目的是简化java语言对protobuf类库的使用，无需再去了解proto文件操作与语法，直接使用java注解定义字段类型即可。protobuf性能主要消耗在文件的预编译上，因此jprotobuf提供的maven预编译插件，在工程编译/打包时生成protobuf二进制文件。

引入依赖

```xml
<!--jprotobuf-precompile-plugin 支持maven编译时同时进行jprotobuf对象的预编译操作.-->
<dependency>
    <groupId>com.baidu</groupId>
    <artifactId>jprotobuf-precompile-plugin</artifactId>
    <version>2.0.3</version>
</dependency>
<!--百度封装的protobuf API-->
<dependency>
    <groupId>com.baidu</groupId>
    <artifactId>jprotobuf</artifactId>
    <version>2.1.11</version>
</dependency>
```

引入插件

```xml
<plugin>
    <groupId>com.baidu</groupId>
    <artifactId>jprotobuf-precompile-plugin</artifactId>
    <version>2.0.3</version>
    <configuration>
        <!--<skipErrorNoDescriptorsFound>true</skipErrorNoDescriptorsFound>-->
        <filterClassPackage>com.baidu</filterClassPackage>
    </configuration>
    <executions>
        <execution>
            <phase>compile</phase>
            <goals>
                <goal>precompile</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

实现

```java
public class ProtobufSerializable extends AbstractSerializableByte {

	private Codec userCodec;

	public <T> ProtobufSerializable(T object) {
		super(object);
	}

	@Override
	public <T> void init(T object) {
		this.userCodec = ProtobufProxy.create(object.getClass());
	}

	@Override
	public <T> byte[] serializableByte(T object) {
		try {
			return userCodec.encode(object);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}


	@Override
	public <T> T deSerializable(Class<T> clazz, byte[] byteIn) {
		return deSerializable(byteIn);
	}

	private <T> T deSerializable(byte[] byteIn) {
		try {
			return (T) userCodec.decode(byteIn);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

}
```

# 性能测试

```bash
测试平台：Windows10
硬件信息：CPU  Core-i5-2430M  2.4GHz
       内存8G
JDK版本: 1.8.0_65
测试方法：1、每组测试先对JVM进行预热
        2、每种实现分三组进行，分别序列化一千、一万、十万次，每组执行100次，取平均值 
```

首先，各执行一次，比较每种序列化后的字节长度，结果如下图

![](序列化后的字节大小比较.png)

从结果看，java原生的序列化生成的字节大小非常大，hessian其次，三种json序列化大小一样，然后是protobuf、messagepack和kryo，接下来比较性能，测试方法如下：

```java
public class Test {

	public static void main(String[] args) throws Exception {
		User user = new User();
		user.setName("小明");
		user.setAge(18);

		long total = 0L;
        //根据实际的实现替换
		ISerializable serializable = new ProtobufSerializable(user);
		//测试次数
		int loop = 100;
		for (int i = 0; i < loop; i++) {
			long start = System.currentTimeMillis();
			for (int j = 0; j < Constant.total; j++) {
				serializable.doSerializable(user);
			}
			long time = System.currentTimeMillis() - start;
			System.out.printf("第%d次耗时:%dms \n", i + 1, time);
			total += time;
		}
		System.out.printf("平均耗时:%dms \n", (total / loop));
	}
}
```

测试过程省略，直接看测试结果



![](序列化性能比较.png)

从测试结果得出以下结论：

1. Java原生的序列化/反序列化性能最差，生成的字节数也最大，无法跨语言；
2. 三种Json序列化实现里，fastJson最好，jackson其次，gson最差，生成的字节数一样。
3. Hessian略好于java原生实现（dubbo对hessian做了优化，性能比原生的hessian更好），跨语言支持；
4. protobuf >> kryo > Messagepack，这三种序列化后生成的字节数相当，但是protobuf与另两种相比，性能有几倍甚至十几倍的提升，十万次的测试耗时仅相当于其他两种一万次的耗时
5. fastjson的性能最接近protobuf，阿里号称其自从发布以来，性能从未被其他Java实现的JSON库超越，果然牛逼！

最后，测试的完整代码参见：[源码](https://github.com/luochunji/SerializableDemo)

如有不对的地方，欢迎拍砖！