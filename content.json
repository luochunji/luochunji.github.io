{"meta":{"title":"阿吉的技术分享","subtitle":"I'm not just a coder...","description":"keep moving forward","author":"我是阿吉","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2019-01-02T07:36:12.000Z","updated":"2019-01-02T07:46:40.150Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-01-02T07:36:51.000Z","updated":"2019-01-02T07:42:23.582Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"常用设计模式-单例的几种写法","slug":"常用设计模式-单例","date":"2019-01-03T12:12:18.000Z","updated":"2019-01-09T07:57:39.357Z","comments":true,"path":"2019/01/03/常用设计模式-单例/","link":"","permalink":"http://yoursite.com/2019/01/03/常用设计模式-单例/","excerpt":"","text":"单例是Java中最简单也是最常用的设计模式之一，它属于创建型模式，在JVM的启动到停止期间，单例只允许类存在一个实例，这个类的实例是由类自己创建并提供给其他类访问，单例的三个特点： jvm中始终只有一个实例 由类自己创建 为其他类提供唯一实例 单例有多种写法，以下列举最常用的七种写法。 懒汉式懒汉式单例声明一个静态的instance = null的对象，因此类在初始化时，类并不会马上实例化，外部对象要调用该类的实例，只能通过getInstance方法，在第一次调用时进行实例化，起到延迟加载的作用。getInstance方法加了同步锁保证线程安全，但在并发时会造成性能瓶颈 12345678910111213141516171819202122public class LazySingleton &#123; /** * 类加载时并没有初始化（延迟加载） */ private static LazySingleton instance = null; private LazySingleton() &#123; //构造函数私有化 &#125; /** * 使用内置同步锁，线程安全，但在并发下会造成性能问题 * @return */ public static synchronized LazySingleton getInstance() &#123; if (null == instance) &#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; 饿汉式饿汉式单例与懒汉式的区别在于： 类初始化时就进行实例化； getInstance没有加锁; 没有延迟加载，也就意味着即使没有其他类调用，这个实例也一直存在，浪费内存资源，正因为初始化时就实例化，因此不存在线程安全问题，无需在getInstance上加同步锁； 1234567891011121314151617public class EagerSingleton &#123; /** * 类加载时已经初始化 */ private static EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123; //私有化构造函数 &#125; /** * 直接返回已经类加载时已经实例化的对象，不存在线程安全问题 * @return */ public static EagerSingleton getInstance() &#123; return instance; &#125;&#125; 静态内部类式这种方式利用了 classloader 机制来保证初始化 instance 时只有一个线程，即使外部类被加载了，instance 还是未初始化，因为 SingletonHolder 类没有被显式调用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被显示调用从而被加载，那么这个时候用这种写法既可以实现延迟加载，又能保证线程安全性。 123456789101112131415161718192021public class InnerSingleton &#123; /** * 静态内部类在单例类初始化时不会初始化 */ private static class SingletonHolder &#123; private static InnerSingleton INSTANCE = new InnerSingleton(); &#125; private InnerSingleton() &#123; &#125; /** * 调用getInstance方法时，才去加载内部类，懒加载的同时也节约空间，同时也是线程安全的 * * @return */ public static InnerSingleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 双重校验式​双重校验在没有加volatile修饰符时是线程不安全的，多个线程之间彼此看到不到最新的变量值。volatile保证线程之间内存可见性。这种写法虽然用了同步锁，但只有第一次加载时会加锁，因此不存在性能问题。 1234567891011121314151617181920212223242526public class DoubleCheckSingleton &#123; /** * volatile修饰对象，保证线程间内存可见性的问题 */ private volatile static DoubleCheckSingleton instance; private DoubleCheckSingleton() &#123; &#125; public static DoubleCheckSingleton getInstance() &#123; //没有加volatile修饰符时，线程不安全，过程如下 //1、线程AB同时到达这里，此时instance == null if (instance == null) &#123; //2、只有一个线程能进入同步方法，假设A进入，线程B等待 synchronized (DoubleCheckSingleton.class) &#123; //3、线程A先进入，new对象后退出返回实例 //4、线程B后进入，因为线程A实例化后的类，对线程B不可见，此时instance == null，因 此线程B也进行new对象后返回实例 if (instance == null) &#123; instance = new DoubleCheckSingleton(); &#125; &#125; &#125; return instance; &#125;&#125; 枚举式枚举式单例可以说是最简洁、最高效的单例模式，用最少的代码既保证实例唯一，又保证线程安全；缺点只有一个：它无法被继承。 1234567891011public enum EnumSingleton &#123; /** * 枚举变量 */ INSTANCE; public void method()&#123; &#125;&#125; ThreadLocal式很多时候，我们都在考虑线程间变量共享，而ThreadLocal刚好相反，它为每个线程提供一份独立的副本，隔离线程之间对同一变量访问的冲突，互不影响。 12345678910111213141516171819public class ThreadLocalSingleton &#123; /** * ThreadLocal为每个线程提供了副本，互不影响 */ private static final ThreadLocal&lt;ThreadLocalSingleton&gt; TL_SINGLETON = new ThreadLocal&lt;ThreadLocalSingleton&gt;() &#123; @Override protected ThreadLocalSingleton initialValue() &#123; return new ThreadLocalSingleton(); &#125; &#125;; private ThreadLocalSingleton() &#123; &#125; public static ThreadLocalSingleton getInstance() &#123; return TL_SINGLETON.get(); &#125;&#125; CAS式要获得唯一的实例，可以用利用AtomicReference的原子性，利用底层的CAS来实现 123456789101112131415161718192021222324public class CASSingleton &#123; private static AtomicReference&lt;CASSingleton&gt; instance = new AtomicReference&lt;&gt;(); private CASSingleton() &#123; &#125; public static CASSingleton getInstance() &#123; //自旋，直到唯一实例被创建 for (; ; ) &#123; CASSingleton singleton = instance.get(); if (null == singleton) &#123; singleton = new CASSingleton(); if (instance.compareAndSet(null, singleton)) &#123; return singleton; &#125; &#125; else &#123; return singleton; &#125; &#125; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"单例","slug":"单例","permalink":"http://yoursite.com/tags/单例/"}]},{"title":"手写JDK动态代理","slug":"手写JDK动态代理","date":"2018-12-31T10:29:00.000Z","updated":"2019-01-02T01:39:03.237Z","comments":true,"path":"2018/12/31/手写JDK动态代理/","link":"","permalink":"http://yoursite.com/2018/12/31/手写JDK动态代理/","excerpt":"","text":"JDK动态代理放寒假了，学生小明要回家，但是买不到火车票，只好找黄牛购票，用JDK的动态代理实现。 首先定义一个Student接口 123public interface Student &#123; void buy();&#125; 定义小明，实现Student接口 1234567public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println(\"我是小明，我要买票去上海的硬座\"); &#125;&#125; 定义黄牛，实现InvocationHandler接口（JDK的动态代理一定要实现这个接口） 12345678910111213141516171819202122232425public class HuangNiu implements InvocationHandler &#123; private Student target; /** * 生成代理对象 * @param target * @return */ public Object getInstance(Student target) &#123; this.target = target; Class clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"我是黄牛，你要什么票?\"); System.out.println(\"--------------\"); method.invoke(target, args); System.out.println(\"--------------\"); return null; &#125;&#125; 测试类： 1234567public class ProxyTest &#123; public static void main(String[] args) &#123; Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 输出结果： 1234我是黄牛，你要什么票?--------------------我是小明，我要买票去上海的硬座-------------------- 小明要购票，小明不需要自己去售票处，而是找了黄牛，让黄牛代劳，真正购票的人是黄牛 小明 ==&gt;被代理对象 黄牛 ==&gt;代理对象 这时候，运行的是黄牛这个代理类，试着将Proxy.newProxyInstance方法生成的代理类输出 1234567891011121314151617181920212223242526/** * 输出代理对象class * * @param proxy */ private void output(Object proxy) &#123; String className = proxy.getClass().getSimpleName(); String baseDir = getClass().getResource(\"\").getPath(); byte[] data = ProxyGenerator.generateProxyClass(className, new Class[]&#123;Student.class&#125;); FileOutputStream os = null; try &#123; os = new FileOutputStream(baseDir + \"/\" + className + \".class\"); os.write(data); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 得到$Proxy0.class文件（生成的代理类名都是以“$”为前缀，数字为后缀），反编译后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class $Proxy0 extends Proxy implements Student &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void buy() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m3 = Class.forName(\"com.cjluo.chapter1.proxy.jdk.Student\").getMethod(\"buy\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 代理类对被代理对象的所有方法都做了代理，通过代理类的InvocationHandler.invoke调用，因此，自己实现动态代理的关键步骤就是： 生成动态代理类； 编译并代理类并加载代理类class文件； 返回代理类给调用者； 以上涉及的JDK动态代理相关类有 123InvocationHandlerProxyClassLoader 自己实现动态代理首先定义CustomerInvocationHandler接口 1234public interface CustomerInvocationHandler &#123; Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 理一下JDK动态代理的逻辑，方法的调用者调用的是小明的代理对象 ==&gt;黄牛，因此要定义CustomerProxy并在该类中生成黄牛这个代理类： 123456789101112131415161718192021222324252627282930313233public class CustomerProxy &#123; //硬编码代理对象名称 private static final String proxyClassName = \"$Proxy0\"; public static Object newProxyInstance(CustomerClassLoader loader, Class&lt;?&gt;[] interfaces, CustomerInvocationHandler h) &#123; try &#123; //1、生成代理类java文件 File f = generatorProxy(interfaces); //2、编译代理类java为class compilerJava(f); //3、自定义加载器加载class Class clazz = loader.findClass(proxyClassName); //4、生成代理对象并返回 Constructor c = clazz.getConstructor(CustomerInvocationHandler.class); return c.newInstance(h); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 生成代理类java文件代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 生成代理类java文件 * * @param interfaces * @return */private static File generatorProxy(Class&lt;?&gt;[] interfaces) &#123; //接口名 Class clazz = interfaces[0]; String interfaceName = clazz.getName(); //换行 String newLine = \"\\r\\n\"; StringBuffer sb = new StringBuffer(); sb.append(\"package \" + clazz.getPackage().getName() + \";\").append(newLine); sb.append(\"import java.lang.reflect.Method;\").append(newLine); sb.append(\"public class \" + proxyClassName + \" implements \" + interfaceName + \"&#123;\").append(newLine); sb.append(\"protected CustomerInvocationHandler h;\").append(newLine); sb.append(\"public \" + proxyClassName + \"(CustomerInvocationHandler h)&#123;\").append(newLine); sb.append(\" this.h = h; \").append(newLine); sb.append(\"&#125;\").append(newLine); for (Method m : clazz.getMethods()) &#123; sb.append(\"public \" + m.getReturnType().getName() + \" \" + m.getName() + \"()&#123;\").append(newLine); sb.append(\"try&#123;\").append(newLine); sb.append(\"Method m = \" + interfaceName + \".class.getMethod(\\\"\" + m.getName() + \"\\\",new Class[]&#123;&#125;);\").append(newLine); sb.append(\"this.h.invoke(this,m,null);\").append(newLine); sb.append(\"&#125;catch(Throwable e)&#123;\").append(newLine); sb.append(\"&#125;\").append(newLine); sb.append(\"&#125;\").append(newLine); &#125; sb.append(\"&#125;\").append(newLine); String src = sb.toString(); File file = new File(CustomerProxy.class.getResource(\"\").getPath() + \"/\" + proxyClassName + \".java\"); try &#123; FileWriter fw = new FileWriter(file); fw.write(src); fw.flush(); fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return file;&#125; 编译代理类 123456789101112131415161718192021/** * 编译代理类 * * @param f */private static void compilerJava(File f) &#123; //java编译器 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager manager = compiler.getStandardFileManager(null, null, null); Iterable iterable = manager.getJavaFileObjects(f); JavaCompiler.CompilationTask task = compiler.getTask(null, manager, null, null, null, iterable); task.call(); try &#123; manager.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //删除Java文件 f.delete(); &#125;&#125; 自定义加载器加载class 123456789101112131415161718192021222324252627282930313233343536373839public class CustomerClassLoader extends ClassLoader &#123; private File baseDir; public CustomerClassLoader() &#123; String basePath = CustomerClassLoader.class.getResource(\"\").getPath(); this.baseDir = new File(basePath); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String className = getClass().getPackage().getName() + \".\" + name; if (baseDir != null) &#123; File classFile = new File(baseDir, name.replaceAll(\"\\\\.\", \"/\") + \".class\"); if (classFile.exists()) &#123; FileInputStream in = null; ByteArrayOutputStream out = null; try &#123; in = new FileInputStream(classFile); out = new ByteArrayOutputStream(); byte[] buff = new byte[1024]; int len; while ((len = in.read(buff)) != -1) &#123; out.write(buff, 0, len); &#125; return defineClass(className, out.toByteArray(), 0, out.size()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //删除class文件 classFile.delete(); &#125; &#125; &#125; return null; &#125;&#125; 测试类： 1234567public class CustomerProxyTest &#123; public static void main(String[] args) &#123; Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 运行结果 1234我是黄牛，你要什么票?--------------------我是小明，我要买票去上海的硬座--------------------","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"}]},{"title":"常用设计模式 - 代理模式","slug":"常用设计模式-代理模式","date":"2018-12-30T14:08:07.000Z","updated":"2019-01-04T16:11:30.583Z","comments":true,"path":"2018/12/30/常用设计模式-代理模式/","link":"","permalink":"http://yoursite.com/2018/12/30/常用设计模式-代理模式/","excerpt":"","text":"代理模式代理模式是JAVA常用的设计模式之一，代理模式不直调用代理对象，而是通过对象的代理类来处理，好比是中介、黄牛、经纪人，代理模式又分为静态代理和动态代理。 代理对象：面向调用者，在调用者和被代理对象之间作为隔离层加以控制，可以增强被代理对象的方法。 被代理对象：真正的执行者，需要对代理对象暴露 静态代理何为静态？其实就是在编码阶段，写好代理类，然后编译运行，在程序运行前，代理类已经存在。 以学生小明找黄牛购票为例： 123public interface Student &#123; void buy();&#125; 小明： 123456public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println(\"我是学生小明，我要一张去上海的票\"); &#125;&#125; 黄牛： 123456789101112131415161718public class HuangNiu implements Student &#123; private Student target; //代理类实例化时需要传入被代理类实例的引用 public HuangNiu(Student student) &#123; this.target = student; &#125; @Override public void buy() &#123; System.out.println(\"我是黄牛，你要什么票？\"); System.out.println(\"------------\"); //调用被代理类的方法 this.target.buy(); System.out.println(\"------------\"); &#125;&#125; 测试类： 12345678public class StaticProxyTest &#123; public static void main(String[] args) &#123; Student xiaoMing = new XiaoMing(); HuangNiu huangNiu = new HuangNiu(xiaoMing); huangNiu.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票？------------我是学生小明，我要一张去上海的票------------ 动态代理相对于静态代理，动态代理的代理类是在运行时通过反射生成，动态代理在实现上又有两种，分别是jdk动态代理和cglib动态代理。 JDK动态代理JDK动态代理要求被代理对象必须实现接口，其原理是代理对象实现该接口的方法，同时调用被代理对象的方法。将生成后的代理对象，强制转换为接口被调用者调用。还是以小明和黄牛为例： 小明，实现学生接口的buy方法 1234567public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println(\"我是学生，我要买票去上海的硬座\"); &#125;&#125; 黄牛，作为小明的代理实现InvocationHandler 12345678910111213141516171819202122232425public class HuangNiu implements InvocationHandler &#123; private Student target; /** * 生成代理对象 * * @param target * @return */ public Object getInstance(Student target) &#123; this.target = target; Class clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"我是黄牛，你要什么票?\"); System.out.println(\"--------------\"); //代理对象持有被代理对象实例的引用，通过反射调用目标方法 method.invoke(target, args); System.out.println(\"--------------\"); return null; &#125; 测试类： 1234567891011public class ProxyTest &#123; public static void main(String[] args) &#123; /** * 实例化代理类时调用getInstance方法传入了小明的实例，生成代理类==&gt;黄牛，强制转换为Student * 接口，因此实际上是由黄牛去执行买票操作； */ Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票?--------------我是学生，我要买票去上海的硬座-------------- 代理类并没有直接实现Student接口，而是通过反射生成字节码文件的方式，动态生成接口的实现类。 Cglib动态代理与JDK动态代理不同的是，cglib代理不强制被代理类实现接口，它是通过生成代理类的子类，并重写代理类方法来实现的，所以代理类不能用final修饰，还是以小明和黄牛为例： 小明： 123456public class XiaoMing &#123; public void buy() &#123; System.out.println(\"我是学生，我要买票去上海的硬座\"); &#125;&#125; 黄牛： 12345678910111213141516171819202122232425//MethodInterceptor是cglibpublic class HuangNiu implements MethodInterceptor &#123; public Object getInstance(Class clazz)&#123; //cglib封装的高性能的代码生成库 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(clazz); //回调当前实例 enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object target, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"我是黄牛，你要什么票?\"); System.out.println(\"--------------\"); //注意，这里如果用invoke会造成死循环，因为代理类是被代理类的子类，如果调用invokeSuper方法， //会调用父类的方法，而invoke会重复进入当前代理类的方法，造成死循环 methodProxy.invokeSuper(target,objects); System.out.println(\"--------------\"); return null; &#125;&#125; cglib动态代理并没有像JDK动态代理那样，直接持有代理类实例的引用，那么intercept方法的第一个参数Object是怎么生成？根据类加载的顺序，实例化子类前，必先实例化其父类 实例化 ChildClass ==&gt; new FatherClass ==&gt; new ChildClass； 测试类： 1234567public class CglibProxyTest &#123; public static void main(String[] args) &#123; XiaoMing p = (XiaoMing) new HuangNiu().getInstance(XiaoMing.class); p.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票?--------------我是学生，我要买票去上海的硬座-------------- 应用场景代理模式随处可见，最常见的是spring的AOP，比如spring的事务代理，在对数据进行操作时会涉及事务开启、事务提交、事务回滚等操作，简化的数据操作模型如下图： 业务场景中存在大量的事务操作（红色），而这些往往不是开发者的关注点，开发者更注重于业务逻辑（蓝色）。因此代理模式可以增强业务逻辑代码，在事务执行前开启事务，在事务执行后进行回滚/提交/关闭。 总结 静态代理需要编写代理类，动态代理不需要； 静态代理在无需修改被代理类的前提下，对代理类进行增强和扩展，但是静态代理只能对一个被代理类服务，如果被代理类过多，就会产生相应数量的代理类实现与被代理类一致的接口，产生冗余，不易维护； JDK动态代理只要求代理类实现InvocationHandler接口，被代理类实现业务接口即可。 静态代理编译时生成的class的性能高于JDK动态代理通过反射生成class； cglib不要求被代理类实现接口，而是通过继承的方式实现，因此类和方法都不能用final修饰。cglib底层用高性能的字节码生成器，性能高于反射。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"静态代理","slug":"静态代理","permalink":"http://yoursite.com/tags/静态代理/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"}]},{"title":"Redis安装","slug":"Redis安装","date":"2018-08-04T02:45:43.000Z","updated":"2019-01-08T08:32:24.183Z","comments":true,"path":"2018/08/04/Redis安装/","link":"","permalink":"http://yoursite.com/2018/08/04/Redis安装/","excerpt":"","text":"Redis安装在学习Redis之前，首先要安装redis的运行环境，了解它的基础命令和基本知识。 下载redis 进入redis官网的下载页面https://redis.io/download 从这个页面我们可以得到的一些基本信息是，redis分为稳定版和非稳定版，其中偶数版本号为稳定版，奇数版本号为非稳定版。截至目前（2018年8月）最新的稳定版为4.0.11，Beta版为5.0-rc4，如果要下载之前的版本，页面往下拉 有oldVersion可以选择，直接提供下载的是3.2.12版本，如果要找其他版本，你可以通过这个连接http://download.redis.io/releases/下载，我安装的是3.0版本（为什么选3.0？主要原因是我使用redis比较晚，当时是跟着《Redis入门指南》学习，李子骅大牛用的就是3.0来讲解，另一个原因我认为3.0应该是redis的一个里程碑，加入集群支持后，redis完成了分布式的实现，新的embedded string编码格式，LRU算法的优化和其他性能的提升，如果之前接触过Redis，这些功能应该让你感到兴奋，从此memcache有的功能，redis几乎都有了，技术选型中使用redis将是更好的选择） 安装redis在linux下安装 我是在centos6的虚拟机上安装，输入以下命令 1234wget http://download.redis.io/releases/redis-3.0.0.tar.gztar xzf redis-3.0.0.tar.gzcd redis-3.0.0make 逐行执行，成功后再执行 1make install 将启动命令等复制到bin目录中，方便以后敲命令，linux下安装编译比较简单，没有其他依赖。 在windows下安装redis官网上没有windows的安装包，微软发了个补丁让redis可以在windows下运行，但是考虑今后的生产环境应该都会使用linux，所以在windows下也建议以虚拟机或Cygwin的方式运行redis（Cygwin是一个类似虚拟机的linux模拟环境，它将linux下的软件重编译后在linux下运行，而且他的软件包还提供了上千个工具，windows下学习linux相关应用的神器！！！） 首先，在Cygwin官网上下载http://www.cygwin.com/setup-x86_64.exe，根据提示选择下载方式、安装路径、最后出现软件包安装界面 将gcc和make的组件勾选，我这里显示”keep”是因为已经安装过了，如果没安装过，显示的是版本号，Skip表示不安装。 然后下载redis的源码，命令与linux下安装时一样，但是要注意，在make之前还要修改src目录下的redis.h文件，在头部加入 12345#ifdef CYGWIN#ifndef SA ONSTACK#define SA ONSTACK 0x08000000#endif#endif cygwin的文件路径就是安装路径，例如D:\\cygwin64\\，修改文件可以直接找到目录下的文件，用文本编辑器打开修改，也可以在linux下用vim修改。 修改之后在redis根目录执行make，如果报错，请参考这篇文章《redis3.0.6安装（linux和windows）》 启停Redis 首先来了解几个文件，在执行make install之后，redis的几个常用可执行文件会复制到Cygwin的bin目录下，因此可以通过直接输入命令来运行，省去路径 文件/命令 说明 redis-server redis服务端启动 redis-cli redis客户端启动 redis-benchmark redis性能测试 redis-check-aof aof文件修复工具 redis-check-dump rdb文件检查工具 redis-sentinel sentinel服务 启动redis1$ redis-server 出现以上提示，表示启动成功 redis的默认端口为 6379，如果要修改端口，可以用以下参数启动（xxxx用实际端口号替换） 1$ redis-server --port xxxx 也可以通过 1$ redis-server -h 或 $ redis-server --help 查看其他启动参数，具体的启动参数如下 参数 说明 省略 按照默认配置启动 /etc/xxx.conf 按照指定的配置文件启动 -v 或 –version 查看redis版本号 -slaveof ip port 将当前服务器转为指定服务器的slave –loglevel xxx 配置日志级别，xxx有4个可选参数，分别是debug\\verbose\\notice\\warning 停止Redisredis支持优雅停机，在客户端发送shutdown命令，会先断开客户端连接，然后根据配置执行持久化策略，完成后退出 1$ redis-cli shutdown redis可以处理系统的kill命令，效果与shutdown一样，但是kill -9 命令将直接终止redis进程，无法优雅停机 启动命令行客户端 1$ redis-cli 和启动服务端一样，启动客户端也可以使用启动参数 参数 说明 -h hostname，服务端的ip -p port，服务端的端口 -s socket 包含了hostname和port -a password 服务端密码 -r n，n表示重复执行的次数，如-r 100 -i 配合-r命令，命令执行的间隔时间 -n 选择数据库，默认是0 -x 从磁盘/缓冲区读取 -d 设置换行符，默认是”\\n” -c 启用集群 –raw 返回格式化后的输出信息 –no-row 返回原始的输出信息 –csv 以csv格式输出 –stat 查看redis服务的实时状态，基本信息包含keys数量\\memory大小\\client数量\\blocked统计请求数\\连接数等 –latency 服务延迟持续采样，一般用于监视性能，输出平均延时时间 –latency-history 服务延迟持续采样，间隔时间输出，大概每15秒左右输出一组结果 –latency-dist 服务延迟采样，以带色块的频谱（这个翻译可能不太好）输出，默认每1秒输出一行，可以用-i参数修改 –lru-test 针对某个key，测试lru算法 –slave slave服务 –rdb 转储rdb到本地文件 –pipe 将redis协议格式的数据发送的服务端执行 –pipe-timeout 功能同上，带超时参数，默认30秒，如果服务端没有返回结果，自动终止 –bigkeys 查找占用内存较大的key，列出每种数据类型key的最大size和平均size –scan 扫描redis的key –pattern 以sacn的方式，扫描指定的pattern –intrinsic-latency 测试系统延迟，需在server上执行 –eval 执行lua脚本","categories":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/categories/redis/"}],"tags":[{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"Cygwin","slug":"Cygwin","permalink":"http://yoursite.com/tags/Cygwin/"}]}]}