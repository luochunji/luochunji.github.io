{"meta":{"title":"阿吉的技术分享","subtitle":"I'm not just a coder...","description":"keep moving forward","author":"我是阿吉","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2019-01-02T07:36:51.000Z","updated":"2019-01-02T07:42:23.582Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-01-02T07:36:12.000Z","updated":"2019-01-02T07:46:40.150Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"手写JDK动态代理","slug":"手写JDK动态代理","date":"2018-12-31T10:29:00.000Z","updated":"2019-01-02T01:39:03.237Z","comments":true,"path":"2018/12/31/手写JDK动态代理/","link":"","permalink":"http://yoursite.com/2018/12/31/手写JDK动态代理/","excerpt":"","text":"JDK动态代理放寒假了，学生小明要回家，但是买不到火车票，只好找黄牛购票，用JDK的动态代理实现。 首先定义一个Student接口 123public interface Student &#123; void buy();&#125; 定义小明，实现Student接口 1234567public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println(\"我是小明，我要买票去上海的硬座\"); &#125;&#125; 定义黄牛，实现InvocationHandler接口（JDK的动态代理一定要实现这个接口） 12345678910111213141516171819202122232425public class HuangNiu implements InvocationHandler &#123; private Student target; /** * 生成代理对象 * @param target * @return */ public Object getInstance(Student target) &#123; this.target = target; Class clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"我是黄牛，你要什么票?\"); System.out.println(\"--------------\"); method.invoke(target, args); System.out.println(\"--------------\"); return null; &#125;&#125; 测试类： 1234567public class ProxyTest &#123; public static void main(String[] args) &#123; Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 输出结果： 1234我是黄牛，你要什么票?--------------------我是小明，我要买票去上海的硬座-------------------- 小明要购票，小明不需要自己去售票处，而是找了黄牛，让黄牛代劳，真正购票的人是黄牛 小明 ==&gt;被代理对象 黄牛 ==&gt;代理对象 这时候，运行的是黄牛这个代理类，试着将Proxy.newProxyInstance方法生成的代理类输出 1234567891011121314151617181920212223242526/** * 输出代理对象class * * @param proxy */ private void output(Object proxy) &#123; String className = proxy.getClass().getSimpleName(); String baseDir = getClass().getResource(\"\").getPath(); byte[] data = ProxyGenerator.generateProxyClass(className, new Class[]&#123;Student.class&#125;); FileOutputStream os = null; try &#123; os = new FileOutputStream(baseDir + \"/\" + className + \".class\"); os.write(data); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; os.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 得到$Proxy0.class文件（生成的代理类名都是以“$”为前缀，数字为后缀），反编译后的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class $Proxy0 extends Proxy implements Student &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void buy() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m3 = Class.forName(\"com.cjluo.chapter1.proxy.jdk.Student\").getMethod(\"buy\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 代理类对被代理对象的所有方法都做了代理，通过代理类的InvocationHandler.invoke调用，因此，自己实现动态代理的关键步骤就是： 生成动态代理类； 编译并代理类并加载代理类class文件； 返回代理类给调用者； 以上涉及的JDK动态代理相关类有 123InvocationHandlerProxyClassLoader 自己实现动态代理首先定义CustomerInvocationHandler接口 1234public interface CustomerInvocationHandler &#123; Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; 理一下JDK动态代理的逻辑，方法的调用者调用的是小明的代理对象 ==&gt;黄牛，因此要定义CustomerProxy并在该类中生成黄牛这个代理类： 123456789101112131415161718192021222324252627282930313233public class CustomerProxy &#123; //硬编码代理对象名称 private static final String proxyClassName = \"$Proxy0\"; public static Object newProxyInstance(CustomerClassLoader loader, Class&lt;?&gt;[] interfaces, CustomerInvocationHandler h) &#123; try &#123; //1、生成代理类java文件 File f = generatorProxy(interfaces); //2、编译代理类java为class compilerJava(f); //3、自定义加载器加载class Class clazz = loader.findClass(proxyClassName); //4、生成代理对象并返回 Constructor c = clazz.getConstructor(CustomerInvocationHandler.class); return c.newInstance(h); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 生成代理类java文件代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 生成代理类java文件 * * @param interfaces * @return */private static File generatorProxy(Class&lt;?&gt;[] interfaces) &#123; //接口名 Class clazz = interfaces[0]; String interfaceName = clazz.getName(); //换行 String newLine = \"\\r\\n\"; StringBuffer sb = new StringBuffer(); sb.append(\"package \" + clazz.getPackage().getName() + \";\").append(newLine); sb.append(\"import java.lang.reflect.Method;\").append(newLine); sb.append(\"public class \" + proxyClassName + \" implements \" + interfaceName + \"&#123;\").append(newLine); sb.append(\"protected CustomerInvocationHandler h;\").append(newLine); sb.append(\"public \" + proxyClassName + \"(CustomerInvocationHandler h)&#123;\").append(newLine); sb.append(\" this.h = h; \").append(newLine); sb.append(\"&#125;\").append(newLine); for (Method m : clazz.getMethods()) &#123; sb.append(\"public \" + m.getReturnType().getName() + \" \" + m.getName() + \"()&#123;\").append(newLine); sb.append(\"try&#123;\").append(newLine); sb.append(\"Method m = \" + interfaceName + \".class.getMethod(\\\"\" + m.getName() + \"\\\",new Class[]&#123;&#125;);\").append(newLine); sb.append(\"this.h.invoke(this,m,null);\").append(newLine); sb.append(\"&#125;catch(Throwable e)&#123;\").append(newLine); sb.append(\"&#125;\").append(newLine); sb.append(\"&#125;\").append(newLine); &#125; sb.append(\"&#125;\").append(newLine); String src = sb.toString(); File file = new File(CustomerProxy.class.getResource(\"\").getPath() + \"/\" + proxyClassName + \".java\"); try &#123; FileWriter fw = new FileWriter(file); fw.write(src); fw.flush(); fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return file;&#125; 编译代理类 123456789101112131415161718192021/** * 编译代理类 * * @param f */private static void compilerJava(File f) &#123; //java编译器 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager manager = compiler.getStandardFileManager(null, null, null); Iterable iterable = manager.getJavaFileObjects(f); JavaCompiler.CompilationTask task = compiler.getTask(null, manager, null, null, null, iterable); task.call(); try &#123; manager.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //删除Java文件 f.delete(); &#125;&#125; 自定义加载器加载class 123456789101112131415161718192021222324252627282930313233343536373839public class CustomerClassLoader extends ClassLoader &#123; private File baseDir; public CustomerClassLoader() &#123; String basePath = CustomerClassLoader.class.getResource(\"\").getPath(); this.baseDir = new File(basePath); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; String className = getClass().getPackage().getName() + \".\" + name; if (baseDir != null) &#123; File classFile = new File(baseDir, name.replaceAll(\"\\\\.\", \"/\") + \".class\"); if (classFile.exists()) &#123; FileInputStream in = null; ByteArrayOutputStream out = null; try &#123; in = new FileInputStream(classFile); out = new ByteArrayOutputStream(); byte[] buff = new byte[1024]; int len; while ((len = in.read(buff)) != -1) &#123; out.write(buff, 0, len); &#125; return defineClass(className, out.toByteArray(), 0, out.size()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //删除class文件 classFile.delete(); &#125; &#125; &#125; return null; &#125;&#125; 测试类： 1234567public class CustomerProxyTest &#123; public static void main(String[] args) &#123; Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 运行结果 1234我是黄牛，你要什么票?--------------------我是小明，我要买票去上海的硬座--------------------","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"}]},{"title":"常用设计模式 - 代理模式","slug":"常用设计模式-代理模式","date":"2018-12-30T14:08:07.000Z","updated":"2019-01-04T16:11:30.583Z","comments":true,"path":"2018/12/30/常用设计模式-代理模式/","link":"","permalink":"http://yoursite.com/2018/12/30/常用设计模式-代理模式/","excerpt":"","text":"代理模式代理模式是JAVA常用的设计模式之一，代理模式不直调用代理对象，而是通过对象的代理类来处理，好比是中介、黄牛、经纪人，代理模式又分为静态代理和动态代理。 代理对象：面向调用者，在调用者和被代理对象之间作为隔离层加以控制，可以增强被代理对象的方法。 被代理对象：真正的执行者，需要对代理对象暴露 静态代理何为静态？其实就是在编码阶段，写好代理类，然后编译运行，在程序运行前，代理类已经存在。 以学生小明找黄牛购票为例： 123public interface Student &#123; void buy();&#125; 小明： 123456public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println(\"我是学生小明，我要一张去上海的票\"); &#125;&#125; 黄牛： 123456789101112131415161718public class HuangNiu implements Student &#123; private Student target; //代理类实例化时需要传入被代理类实例的引用 public HuangNiu(Student student) &#123; this.target = student; &#125; @Override public void buy() &#123; System.out.println(\"我是黄牛，你要什么票？\"); System.out.println(\"------------\"); //调用被代理类的方法 this.target.buy(); System.out.println(\"------------\"); &#125;&#125; 测试类： 12345678public class StaticProxyTest &#123; public static void main(String[] args) &#123; Student xiaoMing = new XiaoMing(); HuangNiu huangNiu = new HuangNiu(xiaoMing); huangNiu.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票？------------我是学生小明，我要一张去上海的票------------ 动态代理相对于静态代理，动态代理的代理类是在运行时通过反射生成，动态代理在实现上又有两种，分别是jdk动态代理和cglib动态代理。 JDK动态代理JDK动态代理要求被代理对象必须实现接口，其原理是代理对象实现该接口的方法，同时调用被代理对象的方法。将生成后的代理对象，强制转换为接口被调用者调用。还是以小明和黄牛为例： 小明，实现学生接口的buy方法 1234567public class XiaoMing implements Student &#123; @Override public void buy() &#123; System.out.println(\"我是学生，我要买票去上海的硬座\"); &#125;&#125; 黄牛，作为小明的代理实现InvocationHandler 12345678910111213141516171819202122232425public class HuangNiu implements InvocationHandler &#123; private Student target; /** * 生成代理对象 * * @param target * @return */ public Object getInstance(Student target) &#123; this.target = target; Class clazz = target.getClass(); return Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"我是黄牛，你要什么票?\"); System.out.println(\"--------------\"); //代理对象持有被代理对象实例的引用，通过反射调用目标方法 method.invoke(target, args); System.out.println(\"--------------\"); return null; &#125; 测试类： 1234567891011public class ProxyTest &#123; public static void main(String[] args) &#123; /** * 实例化代理类时调用getInstance方法传入了小明的实例，生成代理类==&gt;黄牛，强制转换为Student * 接口，因此实际上是由黄牛去执行买票操作； */ Student huangniu = (Student) new HuangNiu().getInstance(new XiaoMing()); huangniu.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票?--------------我是学生，我要买票去上海的硬座-------------- 代理类并没有直接实现Student接口，而是通过反射生成字节码文件的方式，动态生成接口的实现类。 Cglib动态代理与JDK动态代理不同的是，cglib代理不强制被代理类实现接口，它是通过生成代理类的子类，并重写代理类方法来实现的，所以代理类不能用final修饰，还是以小明和黄牛为例： 小明： 123456public class XiaoMing &#123; public void buy() &#123; System.out.println(\"我是学生，我要买票去上海的硬座\"); &#125;&#125; 黄牛： 12345678910111213141516171819202122232425//MethodInterceptor是cglibpublic class HuangNiu implements MethodInterceptor &#123; public Object getInstance(Class clazz)&#123; //cglib封装的高性能的代码生成库 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(clazz); //回调当前实例 enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object target, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"我是黄牛，你要什么票?\"); System.out.println(\"--------------\"); //注意，这里如果用invoke会造成死循环，因为代理类是被代理类的子类，如果调用invokeSuper方法， //会调用父类的方法，而invoke会重复进入当前代理类的方法，造成死循环 methodProxy.invokeSuper(target,objects); System.out.println(\"--------------\"); return null; &#125;&#125; cglib动态代理并没有像JDK动态代理那样，直接持有代理类实例的引用，那么intercept方法的第一个参数Object是怎么生成？根据类加载的顺序，实例化子类前，必先实例化其父类 实例化 ChildClass ==&gt; new FatherClass ==&gt; new ChildClass； 测试类： 1234567public class CglibProxyTest &#123; public static void main(String[] args) &#123; XiaoMing p = (XiaoMing) new HuangNiu().getInstance(XiaoMing.class); p.buy(); &#125;&#125; 运行结果： 1234我是黄牛，你要什么票?--------------我是学生，我要买票去上海的硬座-------------- 应用场景代理模式随处可见，最常见的是spring的AOP，比如spring的事务代理，在对数据进行操作时会涉及事务开启、事务提交、事务回滚等操作，简化的数据操作模型如下图： 业务场景中存在大量的事务操作（红色），而这些往往不是开发者的关注点，开发者更注重于业务逻辑（蓝色）。因此代理模式可以增强业务逻辑代码，在事务执行前开启事务，在事务执行后进行回滚/提交/关闭。 总结 静态代理需要编写代理类，动态代理不需要； 静态代理在无需修改被代理类的前提下，对代理类进行增强和扩展，但是静态代理只能对一个被代理类服务，如果被代理类过多，就会产生相应数量的代理类实现与被代理类一致的接口，产生冗余，不易维护； JDK动态代理只要求代理类实现InvocationHandler接口，被代理类实现业务接口即可。 静态代理编译时生成的class的性能高于JDK动态代理通过反射生成class； cglib不要求被代理类实现接口，而是通过继承的方式实现，因此类和方法都不能用final修饰。cglib底层用高性能的字节码生成器，性能高于反射。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"},{"name":"静态代理","slug":"静态代理","permalink":"http://yoursite.com/tags/静态代理/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/动态代理/"}]}]}